Object subclass: #BindMessageP3	instanceVariableNames: 'parameters portalName statementName'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!BindMessageP3 commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	parameters	<Collection>	parameters	portalName	<String>	The name of the destination portal 	statementName	<String>	The name of the source prepared statement!!BindMessageP3 methodsFor: 'accessing'!parameters	^parameters! !!BindMessageP3 methodsFor: 'accessing'!parameters: aCollection	parameters := aCollection.	^self! !!BindMessageP3 methodsFor: 'accessing'!portalName	portalName isNil ifTrue: [portalName := String new].	^portalName! !!BindMessageP3 methodsFor: 'accessing'!portalName: aString	portalName := aString.	^self! !!BindMessageP3 methodsFor: 'accessing'!statementName	statementName isNil ifTrue: [statementName := String new].	^statementName! !!BindMessageP3 methodsFor: 'accessing'!statementName: aString	statementName := aString.	^self! !!BindMessageP3 methodsFor: 'printing'!printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	aStream nextPutAll: '>>>>>'; tab.	aStream nextPutAll: self class name.	aStream cr.	aStream nextPutAll: 'Statement name: ' , self statementName printString; cr.	aStream nextPutAll: 'Portal name: ' , self portalName printString; cr.	aStream nextPutAll: 'Parameters: '.	self parameters printOn: aStream.	aStream cr.	^self! !!BindMessageP3 methodsFor: 'instance creation'!parameters: aCollection statement: aName portal: aPortal	"I create instanse of BindMessage with collection of bind variable"	self parameters: aCollection.	self statementName: aName.	self portalName: aPortal.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BindMessageP3 class	instanceVariableNames: ''!!BindMessageP3 class methodsFor: 'message handling'!messageMethod	^#bind:! !!BindMessageP3 class methodsFor: 'instance creation'!parameters: aCollection	"I create instanse of BindMessage with collection of bind variable"	^self basicNew parameters: aCollection statement: nil portal: nil! !!BindMessageP3 class methodsFor: 'instance creation'!parameters: aCollection statement: aName portal: aPortal	"I create instanse of BindMessage with collection of bind variable"	^self basicNew parameters: aCollection statement: aName portal: aPortal! !!BindMessageP3 class methodsFor: 'instance creation'!prameters: aCollection statement: aName	"I create instanse of BindMessage with collection of bind variable"	^self basicNew parameters: aCollection statement: aName portal: nil! !!BindMessageP3 class methodsFor: 'instance creation'!statement: aName	"I create instanse of BindMessage with collection of bind variable"	^self basicNew parameters: #() statement: aName portal: nil! !!BindMessageP3 class methodsFor: 'instance creation'!statement: aName portal: aPortal	"I create instanse of BindMessage with collection of bind variable"	^self basicNew parameters: #() statement: aName portal: aPortal! !Object subclass: #CloseMessageP3	instanceVariableNames: 'name type'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!CloseMessageP3 commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	name	<String>	The name of the prepared statement or portal to close	type	<ByteSymbol>	#statement to close a prepared statement; or #portal to close a portal!!CloseMessageP3 methodsFor: 'accessing'!name	name isNil ifTrue: [name := ''].	^name! !!CloseMessageP3 methodsFor: 'accessing'!target	^type == #portal ifTrue: ['P'] ifFalse: ['S']! !!CloseMessageP3 methodsFor: 'instance creation'!type: aType name: aName	"I create instanse of BindMessage with type(portal ot statement) and portalname"	aType = 'S' ifTrue: [type := #statement].	aType = 'P' ifTrue: [type := #portal].	aType class == Symbol ifTrue: [type := aType].	name := aName.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CloseMessageP3 class	instanceVariableNames: ''!!CloseMessageP3 class methodsFor: 'message handling'!messageMethod	^#close:! !!CloseMessageP3 class methodsFor: 'instance creation'!type: aType name: aName	"I create instanse of BindMessage with type(portal ot statement) and portalname"	^self basicNew type: aType name: aName! !Object subclass: #ConnectionParameterSetP3	instanceVariableNames: 'host port userName password databaseName'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!ConnectionParameterSetP3 commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	databaseName	<String>	DatabaseName	host	<String>	Host name or IP adress	password	<String>	password	port	<Integer>	Port NUmber (ex. 5432)	userName	<String>	UserName!!ConnectionParameterSetP3 methodsFor: 'accessing'!databaseName	^databaseName! !!ConnectionParameterSetP3 methodsFor: 'accessing'!databaseName: aValue	databaseName := aValue! !!ConnectionParameterSetP3 methodsFor: 'accessing'!host	^host! !!ConnectionParameterSetP3 methodsFor: 'accessing'!host: aValue	host := aValue! !!ConnectionParameterSetP3 methodsFor: 'accessing'!password	"^a StringI return the password used to authenticate a user with the name self>>userName.  By default, this is an empty string."	password isNil ifTrue: [password := String new].	^password! !!ConnectionParameterSetP3 methodsFor: 'accessing'!password: aValue	password := aValue! !!ConnectionParameterSetP3 methodsFor: 'accessing'!port	^port! !!ConnectionParameterSetP3 methodsFor: 'accessing'!port: aValue	port := aValue! !!ConnectionParameterSetP3 methodsFor: 'accessing'!userName	^userName! !!ConnectionParameterSetP3 methodsFor: 'accessing'!userName: aValue	userName := aValue! !!ConnectionParameterSetP3 methodsFor: 'printing'!printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	aStream nextPutAll: '>>>>>'; tab.	aStream nextPutAll: self class name.	aStream cr.	aStream nextPutAll: 'Database name: ' , self databaseName printString; cr.	aStream nextPutAll: 'User name: ' , self userName printString; cr.	aStream nextPutAll: 'Host: ' , self host printString; cr.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ConnectionParameterSetP3 class	instanceVariableNames: ''!!ConnectionParameterSetP3 class methodsFor: 'message handling'!messageMethod	^#startupMessage:! !Object subclass: #CopyDataMessageP3	instanceVariableNames: 'copyData'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!CopyDataMessageP3 commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	copyData	<String>	Data that forms part of a COPY data stream!!CopyDataMessageP3 methodsFor: 'accessing'!copyData	"^a String 	I return the string containing the copyData I am to send to the server."	copyData isNil ifTrue: [copyData := String new].	^copyData! !!CopyDataMessageP3 methodsFor: 'accessing'!copyData: aString 	"^self 	I record the string containing the copyData I am to send to the server."	copyData := aString.	^self! !!CopyDataMessageP3 methodsFor: 'initialize-release'!data: aString	self copyData: aString.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CopyDataMessageP3 class	instanceVariableNames: ''!!CopyDataMessageP3 class methodsFor: 'message handling'!messageMethod	^#copyData:! !!CopyDataMessageP3 class methodsFor: 'instance creation'!data: aString	"I create instanse of CopyDataMessage with textual or bynary data"	^self basicNew data: aString! !Object subclass: #DataRowP3	instanceVariableNames: 'fields numberOfColumn'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!DataRowP3 commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	fields	<Array>	The value collection of the column	numberOfColumn	<Integer>	The number of column values that follow (possibly zero)!!DataRowP3 methodsFor: 'accessing'!fields	"^an Array 	I return my array of fields. This is a sparsely poulated represention of the row, where null database 	values are represented by nil."	fields isNil ifTrue: [fields := Array new: self numberOfColumn].	^fields! !!DataRowP3 methodsFor: 'accessing'!numberOfColumn	^numberOfColumn! !!DataRowP3 methodsFor: 'accessing'!numberOfColumn: aNumber	numberOfColumn := aNumber! !Object subclass: #DescribeMessageP3	instanceVariableNames: 'name type'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!DescribeMessageP3 commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	name	<String>	The name of the prepared statement or portal to describe	type	<ByteSymbol>	#prepared to describe a prepared statement; or #portal to describe a portal.!!DescribeMessageP3 methodsFor: 'accessing'!name	name isNil ifTrue: [name := ''].	^name! !!DescribeMessageP3 methodsFor: 'accessing'!target	^type == #portal ifTrue: ['P'] ifFalse: ['S']! !!DescribeMessageP3 methodsFor: 'printing'!printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	aStream nextPutAll: '>>>>>'; tab.	aStream nextPutAll: self class name.	aStream cr.	aStream nextPutAll: 'Type: ' , type printString; cr.	aStream nextPutAll: 'Name: ' , self name printString; cr.	^self! !!DescribeMessageP3 methodsFor: 'instance creation'!type: aType name: aName	"I require describe of columns."	aType = 'S' ifTrue: [type := #prepared].	aType = 'P' ifTrue: [type := #portal].	(aType isKindOf: Symbol) ifTrue: [type := aType].	name := aName.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DescribeMessageP3 class	instanceVariableNames: ''!!DescribeMessageP3 class methodsFor: 'message handling'!messageMethod	^#describe:! !!DescribeMessageP3 class methodsFor: 'instance creation'!type: aType	"I create instanse of DescribeMessage with type(portal ot statement) and portalname"	^self basicNew type: aType name: nil! !!DescribeMessageP3 class methodsFor: 'instance creation'!type: aType name: aName	"I create instanse of DescribeMessage with type(portal ot statement) and portalname"	^self basicNew type: aType name: aName! !Object subclass: #ErrorResponseP3	instanceVariableNames: 'severity code message detail hint position internalPosition internalQuery where schemaName tableName columnName dataTypeName constraintName file line routine'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!ErrorResponseP3 commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	code	<String>	Code: the SQLSTATE code for the error	detail	<String>	Detail: an optional secondary error message carrying more detail about the problem	file	<String>	File: the file name of the source-code location where the error was reported	hint	<String>	Hint: an optional suggestion what to do about the problem	internalPosition	<Integer>	Internal position	internalQuery	<String>	Internal query: the text of a failed internally-generated command	line	<Integer>	Line: the line number of the source-code location where the error was reported	message	<String>	Message: the primary human-readable error message	position	<Integer>	Position: the field value is a decimal ASCII integer, indicating an error cursor position as an index into the original query string	routine	<String>	Routine: the name of the source-code routine reporting the error	severity	<String>	ERROR, FATAL, PANIC, WARNING, NOTICE, DEBUG, INFO, LOG, or a localized translation of one of these	where	<String>	Where: an indication of the context in which the error occurred	schemaName	<String>	SchemaName: the name of the schema containing that object	tableName	<String>	TableName: the name of the table	columnName	<String>	ColumnName: the name of the column	dataTypeName	<String>	DataTypeName: the name of the data type	constraintName	<String>	ConstraintName: the name of the constraint!!ErrorResponseP3 methodsFor: 'accessing'!code	^code! !!ErrorResponseP3 methodsFor: 'accessing'!code: aValue	code := aValue! !!ErrorResponseP3 methodsFor: 'accessing'!columnName	^columnName! !!ErrorResponseP3 methodsFor: 'accessing'!columnName: aValue	columnName := aValue! !!ErrorResponseP3 methodsFor: 'accessing'!constraintName	^constraintName! !!ErrorResponseP3 methodsFor: 'accessing'!constraintName: aValue	constraintName := aValue! !!ErrorResponseP3 methodsFor: 'accessing'!dataTypeName	^dataTypeName! !!ErrorResponseP3 methodsFor: 'accessing'!dataTypeName: aValue	dataTypeName := aValue! !!ErrorResponseP3 methodsFor: 'accessing'!detail	^detail! !!ErrorResponseP3 methodsFor: 'accessing'!detail: aValue	detail := aValue! !!ErrorResponseP3 methodsFor: 'accessing'!file	^file! !!ErrorResponseP3 methodsFor: 'accessing'!file: aValue	file := aValue! !!ErrorResponseP3 methodsFor: 'accessing'!hint	^hint! !!ErrorResponseP3 methodsFor: 'accessing'!hint: aValue	hint := aValue! !!ErrorResponseP3 methodsFor: 'accessing'!internalPosition	^internalPosition! !!ErrorResponseP3 methodsFor: 'accessing'!internalPosition: aValue	internalPosition := aValue asNumber! !!ErrorResponseP3 methodsFor: 'accessing'!internalQuery	^internalQuery! !!ErrorResponseP3 methodsFor: 'accessing'!internalQuery: aValue	internalQuery := aValue! !!ErrorResponseP3 methodsFor: 'accessing'!line	^line! !!ErrorResponseP3 methodsFor: 'accessing'!line: aValue	line := aValue asNumber! !!ErrorResponseP3 methodsFor: 'accessing'!message	^message! !!ErrorResponseP3 methodsFor: 'accessing'!message: aValue	message := aValue! !!ErrorResponseP3 methodsFor: 'accessing'!messageTerminator: aValue	^self! !!ErrorResponseP3 methodsFor: 'accessing'!position	^position! !!ErrorResponseP3 methodsFor: 'accessing'!position: aValue	position := aValue asNumber! !!ErrorResponseP3 methodsFor: 'accessing'!routine	^routine! !!ErrorResponseP3 methodsFor: 'accessing'!routine: aValue	routine := aValue! !!ErrorResponseP3 methodsFor: 'accessing'!schemaName	^schemaName! !!ErrorResponseP3 methodsFor: 'accessing'!schemaName: aValue	schemaName := aValue! !!ErrorResponseP3 methodsFor: 'accessing'!severity	^severity! !!ErrorResponseP3 methodsFor: 'accessing'!severity: aValue	severity := aValue! !!ErrorResponseP3 methodsFor: 'accessing'!tableName	^tableName! !!ErrorResponseP3 methodsFor: 'accessing'!tableName: aValue	tableName := aValue! !!ErrorResponseP3 methodsFor: 'accessing'!where	^where! !!ErrorResponseP3 methodsFor: 'accessing'!where: aValue	where := aValue! !!ErrorResponseP3 methodsFor: 'printing'!printOn: aStream 	"^self 	I return a string representation of myself. I get my superclass 	behavior to do it's thing, then I write out the error message. Error 	messages seem to end with a >>cr, so I don't bother writing one of 	my own."	super printOn: aStream.	aStream nextPutAll: 'Severity: ' , self severity printString; cr.	aStream nextPutAll: 'SQLSTATE code: ' , self code printString; cr.	aStream nextPutAll: 'Error message: ' , self message printString; cr.	aStream nextPutAll: 'Detail message: ' , self detail printString; cr.	aStream nextPutAll: 'Hint: ' , self hint printString; cr.	aStream nextPutAll: 'Cursor Position: ' , self position printString; cr.	aStream nextPutAll: 'Internal Position: ' , self internalPosition printString; cr.	aStream nextPutAll: 'Internal Query: ' , self internalQuery printString; cr.	aStream nextPutAll: 'The Error Occurred: ' , self where printString; cr.	aStream nextPutAll: 'File Name: ' , self file printString; cr.	aStream nextPutAll: 'Line Number: ' , self line printString; cr.	aStream nextPutAll: 'Routine Name: ' , self routine printString; cr.	^self! !!ErrorResponseP3 methodsFor: 'services'!finalizeStartupFor: aConnection 	"^self 	I've been received from the back end in response to a startup packet. 	This is bad news - it means that an error occured during startup, 	and the connection will not become active. I throw an exception to 	that effect."	PostgreSQLP3ErrorResponse raiseSignal: severity , ': ' , code , ':' , message.	^self! !!ErrorResponseP3 methodsFor: 'services'!raise	PostgreSQLP3ErrorResponse raiseSignal: severity , ': ' , code , ':' , message.! !Object subclass: #ExecuteMessageP3	instanceVariableNames: 'portal maxRows'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!ExecuteMessageP3 commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	maxRows	<SmallInteger>	Maximum number of rows to return, if portal contains a query that returns rows (ignored otherwise). Zero denotes "no limit".	portal	<String>	The name of the portal to execute (an empty string selects the unnamed portal).!!ExecuteMessageP3 methodsFor: 'accessing'!maxRows	maxRows isNil ifTrue: [maxRows := 0].	^maxRows! !!ExecuteMessageP3 methodsFor: 'accessing'!portal	portal isNil ifTrue: [portal := ''].	^portal! !!ExecuteMessageP3 methodsFor: 'printing'!printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	aStream nextPutAll: '>>>>>'; tab.	aStream nextPutAll: self class name.	aStream cr.	aStream nextPutAll: 'Portal: ' , self portal printString; cr.	aStream nextPutAll: 'Max rows: ' , self maxRows printString; cr.	^self! !!ExecuteMessageP3 methodsFor: 'instance creation'!portal: aString maxRows: aNumber	"I create instanse of ExecuteMessage with max rows.	By protocol 3, you can get arbitrary rows."	portal := aString.	maxRows := aNumber.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ExecuteMessageP3 class	instanceVariableNames: ''!!ExecuteMessageP3 class methodsFor: 'message handling'!messageMethod	^#execute:! !!ExecuteMessageP3 class methodsFor: 'instance creation'!maxRows: aNumber	"I create instanse of ExecuteMessage with max rows.	By protocol 3, you can get arbitrary rows."	^self basicNew portal: '' maxRows: aNumber! !!ExecuteMessageP3 class methodsFor: 'instance creation'!new	"^a PostgreSQLFrontendMessage subclass 	I return a new instance of myself within the context of aContextParent."	^self basicNew portal: '' maxRows: 0! !!ExecuteMessageP3 class methodsFor: 'instance creation'!portal: aString	"I create instanse of ExecuteMessage with max rows.	By protocol 3, you can get arbitrary rows but this method get all rows."	^self basicNew portal: aString maxRows: 0! !!ExecuteMessageP3 class methodsFor: 'instance creation'!portal: aString maxRows: aNumber	"I create instanse of ExecuteMessage with max rows.	By protocol 3, you can get arbitrary rows."	^self basicNew portal: aString maxRows: aNumber! !Object subclass: #FieldDescriptionP3	instanceVariableNames: 'name objectID typeSize typeModifier tableObjectID attributeNumber formatCode'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!FieldDescriptionP3 commentStamp: 'ty 2/26/2017 15:41' prior: 0!FieldDescriptionP3 is a part of RowDescription.Instance Variables	attributeNumber	<Integer>	If the field can be identified as a column of a specific table, the attribute number of the column; otherwise zero.	formatCode	<Integer>	The format code being used for the field. Currently will be zero (text) or one (binary).	name	<String>	The field name.	objectID	<Integer>	The object ID of the field''s data type.	tableObjectID	<Integer>	If the field can be identified as a column of a specific table, the attribute number of the column; otherwise zero.	typeModifier	<Integer>	The type modifier (see pg_attribute.atttypmod). 	typeSize	<Integer>	The data type size (see pg_type.typlen). Note that negative values denote variable-width types.!!FieldDescriptionP3 methodsFor: 'accessing'!attributeNumber	^attributeNumber! !!FieldDescriptionP3 methodsFor: 'accessing'!attributeNumber: aNumber	attributeNumber := aNumber! !!FieldDescriptionP3 methodsFor: 'accessing'!formatCode	^formatCode! !!FieldDescriptionP3 methodsFor: 'accessing'!formatCode: aCode	formatCode := aCode! !!FieldDescriptionP3 methodsFor: 'accessing'!name	^name! !!FieldDescriptionP3 methodsFor: 'accessing'!name: aString	name := aString! !!FieldDescriptionP3 methodsFor: 'accessing'!objectID	^objectID! !!FieldDescriptionP3 methodsFor: 'accessing'!objectID: aNumber	objectID := aNumber! !!FieldDescriptionP3 methodsFor: 'accessing'!tableObjectID	^tableObjectID! !!FieldDescriptionP3 methodsFor: 'accessing'!tableObjectID: aNumber	tableObjectID := aNumber! !!FieldDescriptionP3 methodsFor: 'accessing'!typeModifier	^typeModifier! !!FieldDescriptionP3 methodsFor: 'accessing'!typeModifier: aNumber	typeModifier := aNumber! !!FieldDescriptionP3 methodsFor: 'accessing'!typeSize	^typeSize! !!FieldDescriptionP3 methodsFor: 'accessing'!typeSize: aNumber	typeSize := aNumber! !!FieldDescriptionP3 methodsFor: 'printing'!printOn: aStream 	"^self 	I return a string representation of myself. ."	aStream nextPutAll: 'Field description.  Name: ' , self name.	aStream nextPutAll: '.  Object ID of the Table: ' , self tableObjectID printString.		aStream nextPutAll: '.  Attribute Number: ' , self attributeNumber printString.	aStream nextPutAll: '.  Object ID: ' , self objectID printString.	aStream nextPutAll: '.  Type size: ' , self typeSize printString.	aStream nextPutAll: '.  Type modifier: ' , self typeModifier printString.	aStream nextPutAll: '.  Format Code: ' , self formatCode printString; cr.	^self! !Object subclass: #FunctionCallMessageP3	instanceVariableNames: 'contextParent function arguments isBinary functionResponse'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!FunctionCallMessageP3 commentStamp: 'ty 2/26/2017 15:41' prior: 0!This class is used for OID type (Large Objects).The Function Call sub-protocol is a legacy feature that is probably best avoided in new code. Similar results can be accomplished by setting up a prepared statement that does SELECT function($1, ...). The Function Call cycle can then be replaced with Bind/Execute.Instance Variables	arguments	<Collection>	The values of the argument	contextParent	<PostgreSQLP3Connection>	function	<Integer>	Specifies the object ID of the function to call	functionResponse	<FunctionCallResponseP3>	The function call result.	isBinary	<Boolean>	The format code for the function result. Must presently be zero (text) or one (binary).!!FunctionCallMessageP3 methodsFor: 'accessing'!addArgument: aPacketValue 	"^self 	I add aPacketValue to my collection of arguments."	self arguments add: aPacketValue.	^self! !!FunctionCallMessageP3 methodsFor: 'accessing'!contextParent	"^an Object	I return the object in whose context I exist."	^contextParent! !!FunctionCallMessageP3 methodsFor: 'accessing'!function	"^self 	I return the function that I represent the invokation of."	^function! !!FunctionCallMessageP3 methodsFor: 'accessing'!function: oid 	"^self 	I record the function that I represent the invokation of."	function := oid.	^self! !!FunctionCallMessageP3 methodsFor: 'accessing'!functionResponse	^functionResponse! !!FunctionCallMessageP3 methodsFor: 'accessing'!isBinary	isBinary isNil ifTrue: [isBinary := true].	^isBinary! !!FunctionCallMessageP3 methodsFor: 'accessing'!isBinary: aBoolean	isBinary := aBoolean! !!FunctionCallMessageP3 methodsFor: 'accessing'!setFunctionName: aFunction 	"^self 	I record the function that I represent the invokation of."	function := self contextParent functionTable at: aFunction.	^self! !!FunctionCallMessageP3 methodsFor: 'services'!connection	^self contextParent connection! !!FunctionCallMessageP3 methodsFor: 'services'!execute	"I execute function."	| queryResults result value |	queryResults := OrderedCollection new.	contextParent frontend sendPacket: self.	[(result := PostgreSQLP3QueryResult for: self) isReadyForQuery]		whileFalse: [queryResults add: result].	result := queryResults first.	result isNil		ifTrue: [value := nil]		ifFalse: 			[self isBinary 				ifTrue: [value := result]				ifFalse: [value := contextParent readStream fromPacketValue: result]].	functionResponse := value! !!FunctionCallMessageP3 methodsFor: 'instance creation'!for: aContextParent	"I create instanse of FunctionCalLMessage.	This message exists for backward compatibility."	self contextParent: aContextParent.	^self! !!FunctionCallMessageP3 methodsFor: 'private'!arguments	"^an OrderedCollection 	I return my collection of arguments. They must all be message values."	arguments isNil ifTrue: [arguments := OrderedCollection new].	^arguments! !!FunctionCallMessageP3 methodsFor: 'private'!contextParent: aContextParent 	"^self	I record the connection context within which I exist."	contextParent := aContextParent.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FunctionCallMessageP3 class	instanceVariableNames: ''!!FunctionCallMessageP3 class methodsFor: 'message handling'!messageMethod	^#functionCall:! !!FunctionCallMessageP3 class methodsFor: 'instance creation'!for: aContextParent 	"I create instanse of FunctionCallMessage.	This message exists for backward compatibility."	^self basicNew for: aContextParent! !Object subclass: #FunctionCallResponseP3	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!FunctionCallResponseP3 commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	value	<Object>	The value of the function result, in the format indicated by the associated format code!!FunctionCallResponseP3 methodsFor: 'testing'!isReadyForQuery	^false! !!FunctionCallResponseP3 methodsFor: 'accessing'!value	^value! !!FunctionCallResponseP3 methodsFor: 'accessing'!value: aValue	value := aValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FunctionCallResponseP3 class	instanceVariableNames: ''!!FunctionCallResponseP3 class methodsFor: 'instance creation'!value: aValue	^self new value: aValue! !ErrorResponseP3 subclass: #NoticeResponseP3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!NoticeResponseP3 commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables!!NoticeResponseP3 methodsFor: 'services' stamp: 'a 3/21/2017 00:53'!raise 	"^a Message 	The key result of my arrival is that a proceedable exception is 	thrown. Once that's out of the way, I resume reading messages from 	the input stream."	| exception |	exception := PostgreSQLP3NoticeResponse new.	exception messageText: self message.	exception parameter: self.	exception signal! !Object subclass: #NotificationResponseP3	instanceVariableNames: 'proccessID channel payload'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!NotificationResponseP3 commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	channel	<String>	The name of the channel that the notify has been raised on.	condition	<MessageForwarder | Object | ProtoObject | ProtoObject>	description of condition	payload	<String>	The "payload" string passed from the notifying process.The "payload" does not understood under 9.0.	proccessID	<Integer>	The process ID of the notifying backend process.!!NotificationResponseP3 methodsFor: 'services' stamp: 'a 3/21/2017 00:52'!raise 	"^a Message 	The key result of my arrival is that a proceedable exception is 	thrown. Once that's out of the way, I resume reading messages from 	the input stream."	| exception |	exception := PostgreSQLP3NotificationResponse new.	exception parameter: self.	exception signal! !!NotificationResponseP3 methodsFor: 'accessing'!channel	^channel! !!NotificationResponseP3 methodsFor: 'accessing'!channel: anObject	channel := anObject! !!NotificationResponseP3 methodsFor: 'accessing'!payload	^payload! !!NotificationResponseP3 methodsFor: 'accessing'!payload: anObject	payload := anObject! !!NotificationResponseP3 methodsFor: 'accessing'!proccessID	^proccessID! !!NotificationResponseP3 methodsFor: 'accessing'!proccessID: anObject	proccessID := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NotificationResponseP3 class	instanceVariableNames: ''!!NotificationResponseP3 class methodsFor: 'instance creation'!new	"Answer a newly created and initialized instance."	^super new initialize! !Object subclass: #ParameterDescriptionP3	instanceVariableNames: 'parameters parameterSize'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!ParameterDescriptionP3 commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	parameters	<Array>	Specifies the object ID of the parameter data type.	parameterSize	<Integer>	The number of parameters used by the statement (can be zero).!!ParameterDescriptionP3 methodsFor: 'accessing'!parameterSize	^parameterSize! !!ParameterDescriptionP3 methodsFor: 'accessing'!parameterSize: aNumber	parameterSize := aNumber! !!ParameterDescriptionP3 methodsFor: 'accessing'!parameters	parameters isNil ifTrue: [parameters := Array new: self parameterSize].	^parameters! !Object subclass: #ParseMessageP3	instanceVariableNames: 'queryString preparedName dataTypes'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!ParseMessageP3 commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	dataTypes	<Array>	Specifies the object ID of the parameter data type. Placing a zero here is equivalent to leaving the type unspecified.	preparedName	<String>	The name of the destination prepared statement (an empty string selects the unnamed prepared statement).	queryString	<String>	The query string to be parsed.!!ParseMessageP3 methodsFor: 'accessing'!dataTypes	"^a Collection 	I return the collection of data type I am to send to the server."	dataTypes isNil ifTrue: [dataTypes := Array new].	^dataTypes! !!ParseMessageP3 methodsFor: 'accessing'!dataTypes: aCollection	"^self 	I record the collection of data types I am to send to the server."	dataTypes := aCollection.	^self! !!ParseMessageP3 methodsFor: 'accessing'!preparedName	"^a String 	I return the prepared name for the query I am to send to the server.	TwoByteString is unusable"	preparedName isNil ifTrue: [preparedName := String new].	^preparedName! !!ParseMessageP3 methodsFor: 'accessing'!preparedName: aString 	"^self 	I record the prepared name for the query I am to send to the server."	preparedName := aString.	^self! !!ParseMessageP3 methodsFor: 'accessing'!queryString	"^a String 	I return the string containing the query I am to send to the server."	queryString isNil ifTrue: [queryString := String new].	^queryString! !!ParseMessageP3 methodsFor: 'accessing'!queryString: aString 	"^self 	I record the string containing the query I am to send to the server."	queryString := aString.	^self! !!ParseMessageP3 methodsFor: 'printing'!printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	aStream nextPutAll: '>>>>>'; tab.	aStream nextPutAll: self class name.	aStream cr.	aStream nextPutAll: 'Data types: '.	self dataTypes printOn: aStream.	aStream cr.	aStream nextPutAll: 'Prepared name: ' , self preparedName printString; cr.	aStream nextPutAll: 'Query string: '.	(queryString first: 100) printOn: aStream.	aStream cr.	^self! !!ParseMessageP3 methodsFor: 'initialize-release'!query: aString as: aName types: aCollection	"I create instanse of ParseMessage.	You can stock some sql by setting name.	You can also preserve a type of bind variables."	self queryString: aString.	self preparedName: aName.	self dataTypes: aCollection.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ParseMessageP3 class	instanceVariableNames: ''!!ParseMessageP3 class methodsFor: 'message handling'!messageMethod	^#parse:! !!ParseMessageP3 class methodsFor: 'instance creation'!query: aString	"I create instanse of ParseMessage."	^self basicNew query: aString as: nil types: nil! !!ParseMessageP3 class methodsFor: 'instance creation'!query: aString as: aName	"I create instanse of ParseMessage.	You can stock some sql by setting name."	^self basicNew query: aString as: aName types: nil! !!ParseMessageP3 class methodsFor: 'instance creation'!query: aString as: aName types: aCollection	"I create instanse of ParseMessage.	You can stock some sql by setting name.	You can also preserve a type of bind variables."	^self basicNew query: aString as: aName types: aCollection! !!ParseMessageP3 class methodsFor: 'instance creation'!query: aString types: aCollection	"I create instanse of ParseMessage.	You can preserve a type of bind variables."	^self basicNew query: aString as: nil types: aCollection! !Object subclass: #PasswordMessageP3	instanceVariableNames: 'salt passwordBytes userName password authenticationType'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!PasswordMessageP3 commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	authenticationType	<ByteSymbol>	The Authentication Type, MD5 or ClearText	password	<String>	The password (plaintext).	passwordBytes	<ByteArray>	The password (encrypted, if requested).	salt	<ByteArray>	A salt, random data that are used as an additional input to make passwordBytes.	userName	<String>	The userName!!PasswordMessageP3 methodsFor: 'accessing'!packetSize	"^an IntValue 	I return an Int value with a size of 32 bits and a value of the size of 	my the packet I represent. The packet size, therefore, is 4 + 	<password length> + 1. The final 1 is the null termination in the 	password string."	^4 + self passwordBytes size + 1! !!PasswordMessageP3 methodsFor: 'accessing'!passwordBytes	| pass usernameBytes staticStringAsBytes firstDigest secondDigest |	passwordBytes isNil 		ifTrue:			[pass := password asByteArray.			authenticationType == #Cleartext				ifTrue: [^passwordBytes := pass].			authenticationType == #MD5				ifTrue:					[pass := password asByteArray.					usernameBytes := userName asByteArray.					firstDigest := self digestFrom: pass , usernameBytes.					secondDigest := self digestFrom: firstDigest , self salt.					staticStringAsBytes := 'md5' asByteArray.					passwordBytes := staticStringAsBytes , secondDigest.					^passwordBytes]]		ifFalse: [^passwordBytes]! !!PasswordMessageP3 methodsFor: 'accessing'!salt	^salt! !!PasswordMessageP3 methodsFor: 'encoding' stamp: 'a 3/26/2017 01:32'!digestFrom: bytes 	"For Squeak only	^a ByteArrayPostgreSQL uses the following method for producing an MD5 digest:	1. Get the MD5 digest for the bytes.  This yields a 16 byte digest.	2. Convert the digest into a 32 character hex string (e.g. 0a2b3c...)		Note: the letters in the hex string *must* be lower case!!	3. Convert the hex string back to bytes yeilding a 32 byte array."	"Squeak original"	| md5Class |	md5Class := MD5.	^(md5Class hashMessage: bytes) hex asLowercase asByteArray! !!PasswordMessageP3 methodsFor: 'testing'!isReadyForQuery	^false! !!PasswordMessageP3 methodsFor: 'printing'!printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	aStream nextPutAll: '>>>>>'; tab.	aStream nextPutAll: self class name.	aStream cr.	aStream nextPutAll: 'Packet size: ' , self packetSize value printString; cr.	aStream nextPutAll: 'Password: ' , self passwordBytes asString printString; cr.	^self! !!PasswordMessageP3 methodsFor: 'initialize-release'!userName: aUserName password: aPassword	"I create instanse of PasswordMessage for clear context."	password := aPassword.	authenticationType := #Cleartext.	^self! !!PasswordMessageP3 methodsFor: 'initialize-release'!userName: aUserName password: aPassword salt: bytes	"I create instanse of PasswordMessage for MD5."	userName := aUserName.	password := aPassword.	salt := bytes.	authenticationType := #MD5.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PasswordMessageP3 class	instanceVariableNames: ''!!PasswordMessageP3 class methodsFor: 'message handling'!messageMethod	^#passwordMessage:! !!PasswordMessageP3 class methodsFor: 'instance creation'!userName: aUserName password: aPassword	"I create instanse of PasswordMessage for clear context."	^self basicNew userName: aUserName password: aPassword! !!PasswordMessageP3 class methodsFor: 'instance creation'!userName: aUserName password: aPassword salt: bytes	"I create instanse of PasswordMessage for MD5."	^self basicNew userName: aUserName password: aPassword salt: bytes! !Object subclass: #PostgreSQLP3BackendMessage	instanceVariableNames: 'message contextParent readStream socket encoding'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!PostgreSQLP3BackendMessage commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	contextParent	<PostgreSQLP3QueryResult>	message	<ByteSymbol>	One length ByteSymbol to identify message class!!PostgreSQLP3BackendMessage methodsFor: 'message'!authentication	| authenticationResponse |	self bufferNext: 4.	authenticationResponse := self readInt32.	^self perform: (self class authenticationCodeAt: authenticationResponse)! !!PostgreSQLP3BackendMessage methodsFor: 'message'!backendKeyData	"^self 	I initialize myself to know the pid and secret key of the backend process."	| aDic processID secretKey |	aDic := Dictionary new.	self bufferNext: 4.	processID := self readInt32.	secretKey := self readInt32.	aDic at: #processID put: processID.	aDic at: #secretKey put: secretKey.	contextParent backendKeyData: aDic.	contextParent backendLog: aDic.	^self continew! !!PostgreSQLP3BackendMessage methodsFor: 'message'!bindComplete	"^self 	I initialize myself as an empty query response. This means reading the 	'unused' string that forms a part of the response, and that's about it."	self bufferNext: 4.	contextParent backendLog: #bindComplete.	^self continew! !!PostgreSQLP3BackendMessage methodsFor: 'message'!closeComplete	"Close(F) does not return CommandComplete(B).	If I return self, PostgreSQLP3QueryResult isReadyForQuery is false.	Therefore, I read next message and return"	self bufferNext: 4.	contextParent backendLog: #closeComplete.	^self continew! !!PostgreSQLP3BackendMessage methodsFor: 'message'!commandComplete	| commandTag |	self bufferNext: 4.	commandTag := self readString.	contextParent connection commandTag add: commandTag.	contextParent addCompletedResponse: self.	contextParent backendLog: #commendComplete , commandTag.	^self! !!PostgreSQLP3BackendMessage methodsFor: 'message'!copyDone	"^self 	I initialize myself as an empty query response. This means reading the 	'unused' string that forms a part of the response, and that's about it."	self bufferNext: 4.	contextParent backendLog: #copyDone.	^self continew! !!PostgreSQLP3BackendMessage methodsFor: 'message'!copyInResponse	| length |	length := self readInt32.	self bufferNext: length - 4.	contextParent backendLog: #copyInResponse.	^self! !!PostgreSQLP3BackendMessage methodsFor: 'message'!copyOutResponse	| wholeFormat columnCount |	self bufferNext: 4.	wholeFormat := self readInt8.	columnCount := self readInt16.	self bufferNext: columnCount * 2.	wholeFormat = 0		ifTrue: 			[self copyDataTextual.			contextParent rowDescription: RowDescriptionP3 new]		ifFalse:			[self copyDataBinary].	contextParent backendLog: #copyOutResponse.	^self perform: message! !!PostgreSQLP3BackendMessage methodsFor: 'message'!dataRow	"^self 	I initialize myself as a row description response. I read the number of fields 	and all the field descriptions from aStream."	| dataRow |	[message == #dataRow]		whileTrue:			[self bufferNext: 4.			dataRow := DataRowP3 new.			dataRow numberOfColumn: self readInt16.			1 to: dataRow numberOfColumn do: 					[:fieldNumber | | fieldSize data | 					fieldSize := self readInt32.					fieldSize = -1						ifTrue: [data := nil]						ifFalse:							[fieldSize := fieldSize value.							data := self bufferNext: fieldSize.							data := self fromPacketValue: data].					dataRow fields at: fieldNumber put: data].			contextParent rows add: dataRow.			message := self getMessageType].	contextParent backendLog: #dataRow.	^self perform: message! !!PostgreSQLP3BackendMessage methodsFor: 'message'!emptyQueryResponse	"^self 	I initialize myself as an empty query response. This means reading the 	'unused' string that forms a part of the response, and that's about it."	self bufferNext: 4.	contextParent backendLog: #emptyQueryResponse.	^self! !!PostgreSQLP3BackendMessage methodsFor: 'message' stamp: 'a 3/21/2017 00:52'!errorResponse	| messageIdentification aMessage errorResponse nextMessage |	self bufferNext: 4.	messageIdentification := (self bufferNext: 1) first asCharacter.	errorResponse := ErrorResponseP3 new.	[messageIdentification == 0 asCharacter]		whileFalse:			[aMessage := self class errorCodeAt: messageIdentification ifAbsent: [PostgreSQLP3UnsupportedFeature raise].			errorResponse perform: aMessage with: self readString.			messageIdentification := (self bufferNext: 1) first asCharacter].	[nextMessage := self continew.	nextMessage isReadyForQuery ifFalse: [PostgreSQLP3UnexpectedMessage signal]]		on: Error		do: [:exception | ].	errorResponse raise! !!PostgreSQLP3BackendMessage methodsFor: 'message'!functionCallResponse	| resultSize |	self bufferNext: 4.	resultSize := self readInt32.	resultSize = -1 ifTrue: [^nil].	resultSize := resultSize value.	^FunctionCallResponseP3 value: (self bufferNext: resultSize)! !!PostgreSQLP3BackendMessage methodsFor: 'message'!noData	"^self 	I initialize myself as an empty query response. This means reading the 	'unused' string that forms a part of the response, and that's about it."	self bufferNext: 4.	contextParent backendLog: #noData.	^self continew! !!PostgreSQLP3BackendMessage methodsFor: 'message'!noticeResponse	| messageIdentification aMessage noticeResponse |	self bufferNext: 4.	messageIdentification := (self bufferNext: 1) first asCharacter.	noticeResponse := NoticeResponseP3 new.	[messageIdentification == 0 asCharacter]		whileFalse:			[aMessage := self class errorCodeAt: messageIdentification ifAbsent: [PostgreSQLP3UnsupportedFeature raise].			noticeResponse perform: aMessage with: self readString.			messageIdentification := (self bufferNext: 1) first asCharacter].	noticeResponse raise.	^self continew! !!PostgreSQLP3BackendMessage methodsFor: 'message'!notificationResponse	"raise resumeable exception"	| notificationResponse |	self bufferNext: 4.	notificationResponse := NotificationResponseP3 new.	notificationResponse proccessID: self readInt32.	notificationResponse channel: self readString.	notificationResponse payload: self readString.	notificationResponse raise.	^self continew! !!PostgreSQLP3BackendMessage methodsFor: 'message'!parameterDescription	"^self 	I initialize myself as a row description response. I read the number of fields 	and all the field descriptions from aStream."	self bufferNext: 4.	contextParent parameterDescription: ParameterDescriptionP3 new.	contextParent parameterDescription parameterSize: self readInt16.	1 to: contextParent parameterDescription parameterSize do: 			[:fieldNumber |			contextParent parameterDescription parameters at: fieldNumber put: self readInt32]. 	contextParent backendLog: contextParent parameterDescription.	^self continew! !!PostgreSQLP3BackendMessage methodsFor: 'message' stamp: 'a 3/26/2017 00:40'!parameterStatus	| key val |	self bufferNext: 4.	key := self readString asSymbol.	val := self readString.	contextParent connection parameterStatus at: key put: val.	key == #'client_encoding'		ifTrue: 			[(ByteArray canUnderstand: #asStringEncoding:)				ifTrue: "For VisualWorks"					[contextParent connection encoding: val]				ifFalse: "For Squeak"					[contextParent connection encoding: #'UTF-8']].	contextParent backendLog: key -> val.	^self continew! !!PostgreSQLP3BackendMessage methodsFor: 'message'!parseComplete	"^self 	I initialize myself as an empty query response. This means reading the 	'unused' string that forms a part of the response, and that's about it."	self bufferNext: 4.	contextParent backendLog: #parseComplete.	^self continew! !!PostgreSQLP3BackendMessage methodsFor: 'message'!portalSuspended	"^self 	I initialize myself as an empty query response. This means reading the 	'unused' string that forms a part of the response, and that's about it."	self bufferNext: 4.	contextParent addCompletedResponse: self.	contextParent backendLog: #portalSuspended.	^self! !!PostgreSQLP3BackendMessage methodsFor: 'message'!readyForQuery	self bufferNext: 4.	contextParent connection transactionStatus: (self bufferNext: 1) first asCharacter.	contextParent backendLog: #readyForQuery.	^self! !!PostgreSQLP3BackendMessage methodsFor: 'message'!rowDescription	"^self 	I initialize myself as a row description response. I read the number of fields 	and all the field descriptions from aStream."	| numberOfFields rowDescription |	self bufferNext: 4.	rowDescription := RowDescriptionP3 new.	numberOfFields := self readInt16.	numberOfFields timesRepeat: 			[| desc |			desc := FieldDescriptionP3 new.			desc name: self readString asString.			desc tableObjectID: self readInt32.			desc attributeNumber: self readInt16.			desc objectID: self readInt32.			desc typeSize: self readInt16.			desc typeModifier: self readInt32.			desc formatCode: self readInt16.			rowDescription fieldDescriptions add: desc].	contextParent backendLog: rowDescription.	contextParent rowDescription: rowDescription.	^self continew! !!PostgreSQLP3BackendMessage methodsFor: 'accessing'!encoding: anEncoding	encoding := anEncoding! !!PostgreSQLP3BackendMessage methodsFor: 'accessing'!message	^message! !!PostgreSQLP3BackendMessage methodsFor: 'testing'!isCompletedResponse	^message == #commandComplete! !!PostgreSQLP3BackendMessage methodsFor: 'testing'!isPortalSuspended	^message == #portalSuspended! !!PostgreSQLP3BackendMessage methodsFor: 'testing'!isReadyForQuery	^message == #readyForQuery! !!PostgreSQLP3BackendMessage methodsFor: 'private'!copyDataBinary	| oids |	message := self getMessageType.	message == #copyData:		ifTrue:			[self bufferNext: 4.			self bufferNext: 11"PGCOPY\n\377\r\n\0".			oids := self readInt16.			self bufferNext: 2]		ifFalse: 			[self perform: message].	[message == #copyDone:]		whileFalse:			[| row data columnCount dataSize|			message == #copyData:				ifTrue:					[self bufferNext: 4.					row := OrderedCollection new.					columnCount := self readInt16.					columnCount bytes asArray = #(255 255) "= File Trailer"						ifTrue: [columnCount := -1].					1 to: columnCount value + oids do:						[:count |						dataSize := self readInt32.						dataSize bytes asArray = #(255 255 255 255)							ifTrue: [data := nil]							ifFalse: [data := self bufferNext: dataSize].						row add: data].					contextParent rows add: row]				ifFalse:					[self perform: message].			message := self getMessageType].	contextParent rows removeLast! !!PostgreSQLP3BackendMessage methodsFor: 'private'!copyDataTextual	"Result list of copy data has no rowDescription.	You get answer by -> 	aPostgreSQLP3QueryResult resultList first collect: [:each | each value asStringEncoding: 'UTF-8']"	| dataSize |	message := self getMessageType.	[message == #copyDone:]		whileFalse:			[message == #copyData:				ifTrue:					[dataSize := self readInt32.					contextParent rows add: (self bufferNext: dataSize - 4)]				ifFalse:					[self perform: message].			message := self getMessageType]! !!PostgreSQLP3BackendMessage methodsFor: 'private' stamp: 'a 3/27/2017 23:56'!readBufferStartingAt: pos to: buffer	"For Squeak"	| amt |	socket waitForDataFor: Socket standardTimeout.		[(amt := socket receiveDataInto: buffer) = 0		ifTrue: [(Delay forMilliseconds: 100) wait].	amt = 0]		whileTrue.				^amt! !!PostgreSQLP3BackendMessage methodsFor: 'service'!connection	"^a PostgreSQLConnectionI return the connection which is at the root of the context tree.  I delegate this to my context parent, which might actually be the connection."	^contextParent connection! !!PostgreSQLP3BackendMessage methodsFor: 'initialize-release'!continew	"read message recursive"	message := self getMessageType.	^self perform: message! !!PostgreSQLP3BackendMessage methodsFor: 'initialize-release'!getMessageType	| messageIdentification |	messageIdentification := (self bufferNext: 1) first asCharacter.	^(self class messageIdentificationCodeAt: messageIdentification ifAbsent: [PostgreSQLP3UnsupportedFeature raise])! !!PostgreSQLP3BackendMessage methodsFor: 'initialize-release'!receivePacketSetInto: aContextParent 	contextParent := aContextParent.	^self continew! !!PostgreSQLP3BackendMessage methodsFor: 'initialize-release'!socket: aSocket	socket := aSocket.	readStream := ReadStream on: (ByteArray new).	^self! !!PostgreSQLP3BackendMessage methodsFor: 'emitting' stamp: 'a 3/27/2017 23:59'!bufferNext: size	| tempSize buffer amt collection |	tempSize := size.	buffer := #[].	[(readStream size - readStream position) < tempSize]		whileTrue: 			[tempSize := tempSize - (readStream size - readStream position).			buffer := buffer, readStream upToEnd.			collection := ByteArray new: self class defaultBufferSize.			amt := self readBufferStartingAt: 1 to: collection.			readStream on: (collection first: amt)].	^buffer, (readStream next: tempSize)! !!PostgreSQLP3BackendMessage methodsFor: 'emitting' stamp: 'a 3/28/2017 00:47'!bufferUpTo: num	| readableSize buffer tempBuffer amt collection |	buffer := #[].	[readableSize := readStream size - readStream position.	tempBuffer := readStream upTo: num.	buffer := buffer , tempBuffer.	readableSize = tempBuffer size]		whileTrue: 			[collection := ByteArray new: self class defaultBufferSize.			amt := self readBufferStartingAt: 1 to: collection.			readStream on: (collection first: amt)].	^buffer! !!PostgreSQLP3BackendMessage methodsFor: 'emitting'!convertSignedInt: bytes	^self class convertSignedInt: bytes! !!PostgreSQLP3BackendMessage methodsFor: 'emitting' stamp: 'a 3/26/2017 01:11'!fromPacketValue: aPacketValue	"In Squeak, you can use utf8 only."	^(ByteArray canUnderstand: #asStringEncoding:)		ifTrue: "For VisualWorks"			[aPacketValue perform: #asStringEncoding: with: (encoding ifNil: [#default])]		ifFalse: "For Squeak"			[aPacketValue asString perform: #utf8ToSqueak]! !!PostgreSQLP3BackendMessage methodsFor: 'emitting'!readInt16	| bytes |	bytes := self bufferNext: 2.	^self convertSignedInt: bytes! !!PostgreSQLP3BackendMessage methodsFor: 'emitting'!readInt32	| bytes |	bytes := self bufferNext: 4.	^self convertSignedInt: bytes! !!PostgreSQLP3BackendMessage methodsFor: 'emitting'!readInt8	| bytes |	bytes := self bufferNext: 1.	^self convertSignedInt: bytes! !!PostgreSQLP3BackendMessage methodsFor: 'emitting'!readString	| bytes |	bytes := self bufferUpTo: 0.	^self fromPacketValue: bytes! !!PostgreSQLP3BackendMessage methodsFor: 'authentication message'!authenticationCleartextPassword	^PasswordMessageP3 userName: self connection parameters userName password: self connection parameters password! !!PostgreSQLP3BackendMessage methodsFor: 'authentication message'!authenticationKerberosV5	^PostgreSQLP3UnsupportedFeature raise! !!PostgreSQLP3BackendMessage methodsFor: 'authentication message'!authenticationMD5Password	| aSalt |	aSalt := self bufferNext: 4.	^PasswordMessageP3 userName: self connection parameters userName password: self connection parameters password salt: aSalt! !!PostgreSQLP3BackendMessage methodsFor: 'authentication message'!authenticationOK	^self continew! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PostgreSQLP3BackendMessage class	instanceVariableNames: ''!!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAt1	^#parseComplete! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAt2	^#bindComplete! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAt3	^#closeComplete! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAtA	^#notificationResponse! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAtC	^#commandComplete! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAtD	^#dataRow! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAtE	^#errorResponse! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAtG	^#copyInResponse! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAtH	^#copyOutResponse! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAtI	^#emptyQueryResponse! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAtK	^#backendKeyData! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAtN	^#noticeResponse! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAtR	^#authentication! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAtS	^#parameterStatus! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAtT	^#rowDescription! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAtV	^#functionCallResponse! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAtZ	^#readyForQuery! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAtc	^#copyDone! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAtd	^#copyData! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAtn	^#noData! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAts	^#portalSuspended! !!PostgreSQLP3BackendMessage class methodsFor: 'messege detection'!messageAtt	^#parameterDescription! !!PostgreSQLP3BackendMessage class methodsFor: 'private'!authenticationCodeAt: aResponse	"^an IdentityDictionaryI return a dictionary of my subclasses indexed by their authentication code as returned by the back end."	^self perform: (#authenticationAt, aResponse printString) asSymbol! !!PostgreSQLP3BackendMessage class methodsFor: 'private'!errorCodeAt: aCharacter ifAbsent: aBlock	^(self class canUnderstand: (#errorAt, aCharacter asSymbol) asSymbol)		ifTrue:			[self perform: (#errorAt, aCharacter asSymbol) asSymbol]		ifFalse:			[aBlock value]! !!PostgreSQLP3BackendMessage class methodsFor: 'private'!messageIdentificationCodeAt: aCharacter ifAbsent: aBlock	^(self class canUnderstand: (#messageAt, aCharacter asSymbol) asSymbol)		ifTrue:			[self perform: (#messageAt, aCharacter asSymbol) asSymbol]		ifFalse:			[aBlock value]! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAt0	^#messageTerminator:! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAtC	^#code:! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAtD	^#detail:! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAtF	^#file:! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAtH	^#hint:! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAtL	^#line:! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAtM	^#message:! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAtP	^#position:! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAtR	^#routine:! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAtS	^#severity:! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAtV	^#severity:! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAtW	^#where:! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAtc	^#columnName:! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAtd	^#dataTypeName:! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAtn	^#constraintName:! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAtp	^#internalPosition:! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAtq	^#internalQuery:! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAts	^#schemaName:! !!PostgreSQLP3BackendMessage class methodsFor: 'error detection'!errorAtt	^#tableName:! !!PostgreSQLP3BackendMessage class methodsFor: 'emitting'!convertSignedInt: bytes	| integer |	integer := ((bytes first bitAnd: 128) bitShift: (bytes size - 1) * 8) negated.	bytes at: 1 put: (bytes first bitAnd: 127).	bytes inject: (bytes size - 1) * 8		into: 			[:bitOffset :byte | 			integer := integer bitOr: (byte asInteger bitShift: bitOffset).			bitOffset - 8].	^integer! !!PostgreSQLP3BackendMessage class methodsFor: 'instance creation'!socket: aSocket	^self basicNew socket: aSocket! !!PostgreSQLP3BackendMessage class methodsFor: 'auth detection'!authenticationAt0	^#authenticationOK! !!PostgreSQLP3BackendMessage class methodsFor: 'auth detection'!authenticationAt2	^#authenticationKerberosV5! !!PostgreSQLP3BackendMessage class methodsFor: 'auth detection'!authenticationAt3	^#authenticationCleartextPassword! !!PostgreSQLP3BackendMessage class methodsFor: 'auth detection'!authenticationAt5	^#authenticationMD5Password! !!PostgreSQLP3BackendMessage class methodsFor: 'auth detection'!authenticationAt6	^#authenticationSCMCredential! !!PostgreSQLP3BackendMessage class methodsFor: 'auth detection'!authenticationAt7	^#authenticationGSS! !!PostgreSQLP3BackendMessage class methodsFor: 'auth detection'!authenticationAt8	^#authenticationGSSContinue! !!PostgreSQLP3BackendMessage class methodsFor: 'auth detection'!authenticationAt9	^#authenticationSSPI! !!PostgreSQLP3BackendMessage class methodsFor: 'constants'!defaultBufferSize	^18! !Object subclass: #PostgreSQLP3Connection	instanceVariableNames: 'parameters stringEncodingName frontend backend backendKeyData dataTypeTable functionTable socket parameterStatus transactionStatus commandTag frontendLoggingBlock backendLoggingBlock'	classVariableNames: 'ActiveConnections CommonLog'	poolDictionaries: ''	category: 'PostgresP3'!!PostgreSQLP3Connection commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	parameters	<ConnectionParameterSetP3>	stringEncodingName	<ByteSymbol>	frontend	<PostgreSQLP3FrontendMessage>	backend	<PostgreSQLP3BackendMessaga>	backendKeyData	<Dictionary>	BackendKeyData(The process ID and the secret key)	dataTypeTable	<IdentityDictionary>	oid -> typname from pg_type	functionTable	<IdentityDictionary>	oid -> proname from pg_proc	socket	<SpSocket>	parameterStatus	<Dictionary>	The name of the run-time parameter -> The current value of the parameter	transactionStatus	<Character>	Current backend transaction status indicator. Possible values are 'I' if idle (not in a transaction block); 'T' if in a transaction block; or 'E' if in a failed transaction block (queries will be rejected until block is ended)	commandTag	<String>	INSERT or DELETE or UPDATE or SELECT or MOVE or FETCH or COPY or SET	frontendLoggingBlock	<BlockClosure>	Logging block for frontend message	backendLoggingBlock	<BlockClosure>	Logging  block for backend message!!PostgreSQLP3Connection methodsFor: 'services'!bind: aCollection 	self bind: aCollection statement: nil portal: nil.	^self! !!PostgreSQLP3Connection methodsFor: 'services'!bind: aCollection statement: aStatement portal: aPortal	frontend sendPacket: (BindMessageP3 parameters: aCollection statement: aStatement portal: aPortal).	^self! !!PostgreSQLP3Connection methodsFor: 'services'!closePortal: aName	frontend sendPacket: (CloseMessageP3 type: #portal name: aName).	^self! !!PostgreSQLP3Connection methodsFor: 'services'!closeStatement: aName	frontend sendPacket: (CloseMessageP3 type: #statement name: aName).	^self! !!PostgreSQLP3Connection methodsFor: 'services'!copyData: aCopyData	frontend sendPacket: (CopyDataMessageP3 data: aCopyData).	^self! !!PostgreSQLP3Connection methodsFor: 'services'!copyDone	| queryResults result |	self commandTag: OrderedCollection new.	queryResults := OrderedCollection new.	self frontend sendPacket: #copyDone.	[(result := PostgreSQLP3QueryResult for: self) isReadyForQuery]		whileFalse: [queryResults add: result].	^queryResults! !!PostgreSQLP3Connection methodsFor: 'services'!copyFail	frontend sendPacket: #copyFail:.	^self! !!PostgreSQLP3Connection methodsFor: 'services'!describe: aName type: aType	frontend sendPacket: (DescribeMessageP3 type: aType name: aName).	^self! !!PostgreSQLP3Connection methodsFor: 'services'!encoding	"^a SymbolThis is just a convinience method for getting the symbol which names the string encoding to the used by the connection."	^self stringEncodingName! !!PostgreSQLP3Connection methodsFor: 'services'!encoding: aSymbol 	"^selfThis is just a convinience method for setting the symbol which names the string encoding to the used by the connection."	| postgreEnc |	postgreEnc := aSymbol asSymbol.	aSymbol = 'EUC_JP' ifTrue: [postgreEnc := #'EUC-JP'].	aSymbol = 'SJIS' ifTrue: [postgreEnc := #ShiftJIS].	aSymbol = 'UTF8' ifTrue: [postgreEnc := #'UTF-8'].	self stringEncodingName: postgreEnc.	self frontend isNil ifFalse: [self frontend encoding: postgreEnc].	self backend isNil ifFalse: [self backend encoding: postgreEnc].! !!PostgreSQLP3Connection methodsFor: 'services'!execute: aPortal maxRows: aCount	"I execute a query message prepared in DB"	self commandTag: OrderedCollection new.	frontend sendPacket: (ExecuteMessageP3 portal: aPortal maxRows: aCount)! !!PostgreSQLP3Connection methodsFor: 'services'!executeQuery: aQueryString 	"^a PostgreSQLQueryResultList 	I create a query message execute it, then return the results."	| queryResults result |	self commandTag: OrderedCollection new.	queryResults := OrderedCollection new.	self frontend sendPacket: (QueryMessageP3 query: aQueryString).	[(result := PostgreSQLP3QueryResult for: self) isReadyForQuery]		whileFalse: [queryResults add: result].	^queryResults! !!PostgreSQLP3Connection methodsFor: 'services'!newFunctionCall	"^a PostgreSQLFunctionCall 	I create and return a new function call which will operate in the context of myself."	^FunctionCallMessageP3 for: self! !!PostgreSQLP3Connection methodsFor: 'services'!prepareQuery: aQueryString 	frontend sendPacket: (ParseMessageP3 query: aQueryString).	^self! !!PostgreSQLP3Connection methodsFor: 'services'!prepareQuery: aQueryString as: aName	frontend sendPacket: (ParseMessageP3 query: aQueryString as: aName).	^self! !!PostgreSQLP3Connection methodsFor: 'services'!sync	"^a PostgreSQLQueryResult 	I get backend-messages after each series of frontend-messages, then return the result."	| result tempResult suspended |	suspended := false.	self frontend sendPacket: #sync.	[(tempResult := PostgreSQLP3QueryResult for: self) isReadyForQuery]		whileFalse: 			[result := tempResult.			suspended := result completedResponses contains: [:each | each isPortalSuspended]].	"PortalSuspended was detected"	(suspended and: [result connection isInTransaction])		ifTrue: [(PostgreSQLP3SuspendedResponse new result: result) raise]. 	^result! !!PostgreSQLP3Connection methodsFor: 'private - sockets'!basicSocket	"^an OSkSocket or nil	Simply returns the current socket, if any."	^socket! !!PostgreSQLP3Connection methodsFor: 'private - sockets' stamp: 'a 3/28/2017 00:23'!socket	"For Squeak only"	socket isNil		ifTrue:			[[Socket initializeNetwork.			socket := Socket newTCP.			socket 				connectTo: (NetNameResolver addressForName: parameters host						timeout: 15)				port: parameters port.			socket waitForConnectionFor: Socket standardTimeout ifTimedOut: [socket := nil].]				on: Error				do: 					[:ex | PostgreSQLP3Error compatibleSignal: ex]].	^socket! !!PostgreSQLP3Connection methodsFor: 'accessing'!backend	^backend! !!PostgreSQLP3Connection methodsFor: 'accessing'!backendKeyData	"^BackendKeyDataMessage 	I return the BackendKeyDataMessage which contains the secret key 	which may be used to cancel requests. The key is a secret between 	me (the connection) and my backend. The idea appears to be to 	prevent interlopers from hijacking my backend."	^backendKeyData! !!PostgreSQLP3Connection methodsFor: 'accessing'!backendKeyData: aValue 	"^self 	I record the BackendKeyDataMessage which contains the secret key 	which may be used to cancel requests."	backendKeyData := aValue! !!PostgreSQLP3Connection methodsFor: 'accessing'!commandTag	^commandTag! !!PostgreSQLP3Connection methodsFor: 'accessing'!commandTag: aString	commandTag := aString! !!PostgreSQLP3Connection methodsFor: 'accessing'!connection	"^selfI can be passed around as a connection context.  All connection contexts must be able to answer the connection they are a part of.  I just return myself because, of course, I am the connection."	^self! !!PostgreSQLP3Connection methodsFor: 'accessing'!dataTypeTable	"^a PostgreSQLDataTypeTable 	I return the table of data types defined in the database that I am a connection to. PostgreSQL allows 	for the definition of new data types, so every database has a (potentially) unique set of data types. 	Given that every connection could be to a distinct backend, I hold a private copy of this table. In 	this implementation, if a new type is added to the database, a new connection should be made: the 	driver will be OK, but some of the interface layers may not like finding a type in a result which is not 	described in the table."	dataTypeTable isNil ifTrue: [dataTypeTable := self dataTypeTableFromBackend].	^dataTypeTable! !!PostgreSQLP3Connection methodsFor: 'accessing'!frontend	^frontend! !!PostgreSQLP3Connection methodsFor: 'accessing'!functionTable	"^a PostgreSQLFunctionTable 	I return the table of functions defined in the database that I am a connection to. PostgreSQL allows 	for the definition of new functions, so every database has a (potentially) unique set of functions. 	Given that every connection could be to a distinct backend, I hold a private copy of this table. In 	this implementation, if a new function is added to the database, a new connection should be made."	functionTable isNil ifTrue: [functionTable := self functionTableFromBackend].	^functionTable! !!PostgreSQLP3Connection methodsFor: 'accessing'!parameterStatus	parameterStatus isNil ifTrue: [parameterStatus := Dictionary new].	^parameterStatus! !!PostgreSQLP3Connection methodsFor: 'accessing'!parameters	"^a ConnectionParametersI return my parameters.  These specify what database I'm a connection to, what host/port the postmaster is on and in whose name I am connection."	^parameters! !!PostgreSQLP3Connection methodsFor: 'accessing'!stringEncodingName	"^a SymbolI return the name of the encoding that is to be presumend to be used for all string values passing between this connection and the PostgreSQL backend."	stringEncodingName isNil ifTrue: [stringEncodingName := #default].	^stringEncodingName! !!PostgreSQLP3Connection methodsFor: 'accessing'!stringEncodingName: aSymbol 	"^selfI record the name of the encoding that is to be presumend to be used for all string values passing between this connection and the PostgreSQL backend."	stringEncodingName := aSymbol.	^self! !!PostgreSQLP3Connection methodsFor: 'accessing'!transactionStatus	^transactionStatus! !!PostgreSQLP3Connection methodsFor: 'accessing'!transactionStatus: aCharacter	transactionStatus := aCharacter! !!PostgreSQLP3Connection methodsFor: 'testing' stamp: 'a 3/28/2017 00:36'!isActive	"^a Boolean 	I return true if I'm. I know this because a) I have an underlying connection, and b) it's active. I use basicSocketSession to avoid any lazy initialization of the socket session."	self basicSocket notNil		ifTrue: 			[(self basicSocket class canUnderstand: #isActive)				ifTrue: "For VisualWorks"					[^self basicSocket perform: #isActive]				ifFalse: "For Squeak"					[^self basicSocket perform: #isValid]].	^false! !!PostgreSQLP3Connection methodsFor: 'testing'!isClosed	"^a Boolean 	I return true if I have been closed. I know this because a) I have an 	underlying connection, and b) it's closed."	^self isActive not! !!PostgreSQLP3Connection methodsFor: 'testing'!isInTransaction	"^a Boolean 	I return false when transactionStatus is $I or $E or nil"	^self transactionStatus = $T! !!PostgreSQLP3Connection methodsFor: 'private'!dataTypeTableFromBackend	"^a PostgreSQLDataTypeTable 	I build a PostgreSQLDataTypeTable by querying the pg_type table of the database I represent a 	connection to. This operation may be moderately expensive."	| result objectId |	objectId := IdentityDictionary new.	result := (self executeQuery: 'select oid, typname from pg_type') first.	result rows do: 			[:aRow |			objectId at: aRow fields first asString asNumber				put: (aRow fields at: 2) asString asSymbol].	^objectId! !!PostgreSQLP3Connection methodsFor: 'private'!functionTableFromBackend	"^a PostgreSQLFunctionTable 	I build a PostgreSQLFunctionTable by querying the pg_proc table of the database I represent a 	connection to. This operation may be moderately expensive."	| result objectId |	objectId := IdentityDictionary new.	result := (self executeQuery: 'select oid, proname from pg_proc') first.	result rows		do: 			[:aRow |			objectId at: aRow fields last asString asSymbol put: aRow fields first asString asNumber].	^objectId! !!PostgreSQLP3Connection methodsFor: 'initialize-release' stamp: 'a 3/21/2017 00:56'!close	self isClosed		ifFalse: 			[[self frontend sendPacket: #terminate]				on: Error				do: [:exception | ].			self socket close].	^self! !!PostgreSQLP3Connection methodsFor: 'initialize-release'!startup	"^self 	I create and initiate a startup message flow. The result of this will 	be an open connection to the back end."	| message |	frontend := PostgreSQLP3FrontendMessage socket: self socket.	backend := PostgreSQLP3BackendMessage socket: self socket.	self frontend logger: self.	self frontend sendPacket: parameters.	message:= self backend receivePacketSetInto: self.	[message isReadyForQuery] whileFalse:		[self frontend sendPacket: message.		message := self backend receivePacketSetInto: self]! !!PostgreSQLP3Connection methodsFor: 'initialize-release'!using: aParameterSet 	"^a Connection 	I initialize myself to represent the connection described by 	aParameterSet."	parameters := aParameterSet.	^self! !!PostgreSQLP3Connection methodsFor: 'logging'!backendLog: aMessage 	"^self 	I log the message using the current logging method as embodied in 	my >>loggingBlock."	self backendLoggingBlock value: aMessage.	^self! !!PostgreSQLP3Connection methodsFor: 'logging'!backendLoggingBlock	"^a BlockClosure 	I return the current logging block. By default, this is a no-op single 	argument block. Logging machinary can replace this block with 	behavior that actually does something."	backendLoggingBlock isNil ifTrue: [backendLoggingBlock := [:aMessage | ]].	^backendLoggingBlock! !!PostgreSQLP3Connection methodsFor: 'logging'!frontendLog: aMessage 	"^self 	I log the message using the current logging method as embodied in 	my >>loggingBlock."	self frontendLoggingBlock value: aMessage.	^self! !!PostgreSQLP3Connection methodsFor: 'logging'!frontendLoggingBlock	"^a BlockClosure 	I return the current logging block. By default, this is a no-op single 	argument block. Logging machinary can replace this block with 	behavior that actually does something."	frontendLoggingBlock isNil ifTrue: [frontendLoggingBlock := [:aMessage | ]].	^frontendLoggingBlock! !!PostgreSQLP3Connection methodsFor: 'logging'!loggingBlockForFront: frontBlock forBack: backBlock 	"^self 	I record the current logging block. c.f. self>>loggingBlock."	frontendLoggingBlock := frontBlock.	backendLoggingBlock := backBlock.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PostgreSQLP3Connection class	instanceVariableNames: ''!!PostgreSQLP3Connection class methodsFor: 'constants'!versionNumber	"(3 bitShift:16) + 0 ="	^196608! !!PostgreSQLP3Connection class methodsFor: 'accessing' stamp: 'a 3/21/2017 00:24'!activeConnections	"^a Set 	I return the set of currently active connections. Under the covers I 	use a WeakArray to maintain this list, but I don't want to hand that 	out because I'm paranoid. I'm providing this service for developers 	so that they can get hold of stray connections. This is also useful for 	the logging machinery. It seems that the elements of a WeakArray 	are replaced with the Integer 0 when they are garbage collected - I 	remove any 0s from the set I return.  I also check for nil, because 	that's possible in Squeak."	ActiveConnections isNil 		ifTrue: [ActiveConnections := WeakArray new: 0].	^(ActiveConnections 		reject: [:anElement | anElement == 0 or: [anElement isNil]]) asSet! !!PostgreSQLP3Connection class methodsFor: 'accessing' stamp: 'a 3/20/2017 23:38'!commonLog	"^ log like thing, or nil 	I return an object which wishes to act as the common logger for all 	of my instances. As logging is really a development time thing, this 	should normally be nil."	^CommonLog! !!PostgreSQLP3Connection class methodsFor: 'accessing' stamp: 'a 3/20/2017 23:39'!commonLog: aLogOfSomeKind 	"^self 	I record the common log (which may be nil). c.f. >>commonLog"	CommonLog := aLogOfSomeKind.	^self! !!PostgreSQLP3Connection class methodsFor: 'instance creation'!using: aParameterSet 	"^a Connection 	I return a new instance of myself on the basis of the information in 	aParameterSet. I make the new instance, add it to my collection of 	active connections, and then start it up. I start it up last so that any 	logging operations get the chance to log the log-in messages."	| newConnection |	newConnection := self new using: aParameterSet.	self addConnection: newConnection.	newConnection startup.	^newConnection! !!PostgreSQLP3Connection class methodsFor: 'private' stamp: 'a 3/21/2017 00:24'!addConnection: aNewConnection 	"^self 	I add aConnection to my collection of connections. I have no 	>>removeConnection: because I assume that old connections will go 	away by themselves when closed (given that I'm using a weak array 	to hold them). I do have a bit of a purge when adding a new 	connection though, and only retain existing connections which 	possitively state that they have not been closed."	| existingConnections |	existingConnections := self activeConnections reject: [:connection | connection isClosed].	existingConnections add: aNewConnection.	ActiveConnections := WeakArray withAll: existingConnections asArray.	self notifyCommonLogOfNewConnection: aNewConnection.	^self! !!PostgreSQLP3Connection class methodsFor: 'private'!notifyCommonLogOfNewConnection: aNewConnection 	"^self 	If there is a common log I tell it to start monitoring aNewConnection."	self commonLog notNil ifTrue: [self commonLog startMonitoring: aNewConnection].	^self! !Error subclass: #PostgreSQLP3Error	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!PostgreSQLP3Error commentStamp: 'ty 2/26/2017 15:41' prior: 0!A superclass of PostgreSql exceptions that should be handled!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PostgreSQLP3Error class	instanceVariableNames: ''!!PostgreSQLP3Error class methodsFor: 'signaling' stamp: 'a 3/28/2017 00:19'!compatibleRaiseSignal: aString	(self class canUnderstand: #raiseSignal:)		ifTrue: "VisualWorks"			[self perform: #raiseSignal: with: aString]		ifFalse: "Squeak"			[self perform: #signal: with: aString]! !!PostgreSQLP3Error class methodsFor: 'signaling' stamp: 'a 3/28/2017 00:25'!compatibleSignal: aParameter	(self class canUnderstand: #signalWith:)		ifTrue: "For VisualWorks"			[self perform: #singalWith: with: aParameter]		ifFalse: "Squeak"			[self perform: #signal: with: aParameter printString]! !PostgreSQLP3Error subclass: #PostgreSQLP3ErrorResponse	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!PostgreSQLP3ErrorResponse commentStamp: 'ty 2/26/2017 15:41' prior: 0!Exceptions that should be handled for ErrorResponse!Object subclass: #PostgreSQLP3FrontendMessage	instanceVariableNames: 'messageClass socket encoding logger'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!PostgreSQLP3FrontendMessage commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	messageClass	<>	Each class or ByteSymbol to send message!!PostgreSQLP3FrontendMessage methodsFor: 'accessing'!encoding: anEncoding	encoding := anEncoding! !!PostgreSQLP3FrontendMessage methodsFor: 'accessing'!logger: aCLass	logger := aCLass! !!PostgreSQLP3FrontendMessage methodsFor: 'message'!bind: aStream 	| byteParams |	byteParams := messageClass parameters collect: 		[:each |		(each isNil or: [each isKindOf: ByteArray])			ifTrue: [each] 			ifFalse: 				[(self class stringFrom: each) asByteArrayEncoding: encoding]].	aStream nextPutAll: (self bytesFromString: 'B').	aStream nextPutAll: (self bytes32FromNumber: 4 + messageClass portalName size + 1 +		messageClass statementName size + 1 + 2 + 		(messageClass parameters size * 2) + 2 +		(messageClass parameters size * 4) +		(byteParams inject: 0 into: [:sum :each | sum + each size]) + 2 + 2).	aStream nextPutAll: (self bytesFromString: messageClass portalName).	aStream nextPut: 0.	aStream nextPutAll: (self bytesFromString: messageClass statementName).	aStream nextPut: 0.	aStream nextPutAll: (self bytes16FromNumber: messageClass parameters size).	(messageClass parameters collect: [:each | each isKindOf: ByteArray]) 		do: [:each | aStream nextPutAll: (self bytes16FromNumber: each coerceToCInteger)].	aStream nextPutAll: (self bytes16FromNumber: messageClass parameters size).	byteParams do:		[:each |		each isNil			ifTrue: [aStream nextPutAll: (self bytes32FromNumber: -1)]			ifFalse: 				[aStream nextPutAll: (self bytes32FromNumber: each size).				aStream nextPutAll: each]].	aStream nextPutAll: (self bytes16FromNumber: 1).	aStream nextPutAll: (self bytes16FromNumber: 0)! !!PostgreSQLP3FrontendMessage methodsFor: 'message'!cancelRequest: aStream	aStream nextPutAll: (self bytes32FromNumber: 16).	aStream nextPutAll: (self bytes32FromNumber: 80877102).	aStream nextPutAll: (self bytes32FromNumber: (aStream connection backendKeyData at: #processID)).	aStream nextPutAll: (self bytes32FromNumber: (aStream connection backendKeyData at: #secretKey)).	^self! !!PostgreSQLP3FrontendMessage methodsFor: 'message'!close: aStream	aStream nextPutAll: (self bytesFromString: 'C').	aStream nextPutAll: (self bytes32FromNumber: 4 + 1 + messageClass name size + 1).	aStream nextPutAll: (self bytesFromString: messageClass target).	aStream nextPutAll: (self bytesFromString: messageClass name).	aStream nextPut: 0.	^self! !!PostgreSQLP3FrontendMessage methodsFor: 'message'!copyData: aStream	| copyBytes |	(messageClass copyData isKindOf: String)		ifTrue:			[copyBytes := messageClass copyData asByteArrayEncoding: aStream connection stringEncodingName]		ifFalse: [copyBytes := messageClass copyData].	aStream nextPutAll: (self bytesFromString: 'd').	aStream nextPutAll: (self bytes32FromNumber: copyBytes size + 4).	aStream nextPutAll: copyBytes.	^self! !!PostgreSQLP3FrontendMessage methodsFor: 'message'!copyDone: aStream	aStream nextPutAll: (self bytesFromString: 'c').	aStream nextPutAll: (self bytes32FromNumber: 4).	^self! !!PostgreSQLP3FrontendMessage methodsFor: 'message'!copyFail: aStream	aStream nextPutAll: (self bytesFromString: 'f').	aStream nextPutAll: (self bytes32FromNumber: 4).	^self! !!PostgreSQLP3FrontendMessage methodsFor: 'message'!describe: aStream	aStream nextPutAll: (self bytesFromString: 'D').	aStream nextPutAll: (self bytes32FromNumber: 4 + 1 + messageClass name size + 1).	aStream nextPutAll: (self bytesFromString: messageClass target).	aStream nextPutAll: (self bytesFromString: messageClass name).	aStream nextPut: 0.	^self! !!PostgreSQLP3FrontendMessage methodsFor: 'message'!execute: aStream	aStream nextPutAll: (self bytesFromString: 'E').	aStream nextPutAll: (self bytes32FromNumber: 4 + messageClass portal size + 1 + 4).	aStream nextPutAll: (self bytesFromString: messageClass portal).	aStream nextPut: 0.	aStream nextPutAll: (self bytes32FromNumber: messageClass maxRows).	^self! !!PostgreSQLP3FrontendMessage methodsFor: 'message'!flush: aStream	aStream nextPutAll: (self bytesFromString: 'H').	aStream nextPutAll: (self bytes32FromNumber: 4).	^self! !!PostgreSQLP3FrontendMessage methodsFor: 'message'!functionCall: aStream	| byteParams |	byteParams := messageClass arguments collect: 		[:each |		each isNil			ifTrue: [nil] 			ifFalse: 				[(each isKindOf: ByteArray)					ifTrue: [each]					ifFalse: 						[self bytesFromString: (self class stringFrom: each)]]].	aStream nextPutAll: (self bytesFromString: 'F').	aStream nextPutAll: (self bytes32FromNumber: 1 + 4 + 4 + 2 + (byteParams size * 2) + 2 +				(byteParams size * 4) + 				(byteParams inject: 0 into: 					[:sum :each | sum + each size]) + 1).	aStream nextPutAll: (self bytes32FromNumber: messageClass function).	aStream nextPutAll: (self bytes16FromNumber: byteParams size).	byteParams do: 		[:each | 		(each isKindOf: ByteArray) 			ifTrue: [aStream nextPutAll: (self bytes16FromNumber: 1)] 			ifFalse: [aStream nextPutAll: (self bytes16FromNumber: 0)]].	aStream nextPutAll: (self bytes16FromNumber: byteParams size).	byteParams do:		[:each |		each isNil			ifTrue: [aStream nextPutAll: (self bytes32FromNumber: -1)] 			ifFalse: 				[aStream nextPutAll: (self bytes32FromNumber: each size).				aStream nextPutAll: each]].	messageClass isBinary		ifTrue: [aStream nextPutAll: (self bytes16FromNumber: 1)]		ifFalse: [aStream nextPutAll: (self bytes16FromNumber: 0)].	^self! !!PostgreSQLP3FrontendMessage methodsFor: 'message'!parse: aStream	| queryBytes |	queryBytes := self bytesFromString: messageClass queryString.	aStream nextPutAll: (self bytesFromString: 'P').	aStream nextPutAll: (self bytes32FromNumber: 4 + messageClass preparedName size + 1 + queryBytes size + 1 + 2 + (messageClass dataTypes size * 4)).	aStream nextPutAll: (self bytesFromString: messageClass preparedName).	aStream nextPut: 0.	aStream nextPutAll: queryBytes.	aStream nextPut: 0.	aStream nextPutAll: (self bytes16FromNumber: messageClass dataTypes size).	messageClass dataTypes do:		[:each |		aStream nextPutAll: (self bytes32FromNumber: (aStream connection dataTypeTable at: each))].	^self! !!PostgreSQLP3FrontendMessage methodsFor: 'message'!passwordMessage: aStream	aStream nextPutAll: (self bytesFromString: 'p').	aStream nextPutAll: (self bytes32FromNumber: messageClass packetSize).	aStream nextPutAll: messageClass passwordBytes.	aStream nextPut: 0.	^self! !!PostgreSQLP3FrontendMessage methodsFor: 'message'!query: aStream	| queryBytes |	queryBytes := self bytesFromString: messageClass queryString.	aStream nextPutAll: (self bytesFromString: 'Q').	aStream nextPutAll: (self bytes32FromNumber: queryBytes size + 5).	aStream nextPutAll: queryBytes.	aStream nextPut: 0.	^self! !!PostgreSQLP3FrontendMessage methodsFor: 'message'!startupMessage: aStream	| packetSize |	packetSize := 4 + "Length of message contents"					4 + "The protocol version number"					'user' size + 1 + 					messageClass userName size + 1 + 					'database' size + 1 + 					messageClass databaseName size + 1 +					"options"'' size + 1.	aStream nextPutAll: (self bytes32FromNumber: packetSize).	aStream nextPutAll: (self bytes32FromNumber: self class versionNumber).	aStream nextPutAll: (self bytesFromString: 'user').	aStream nextPut: 0.	aStream nextPutAll: (self bytesFromString: messageClass userName).	aStream nextPut: 0.	aStream nextPutAll: (self bytesFromString: 'database').	aStream nextPut: 0.	aStream nextPutAll: (self bytesFromString: messageClass databaseName).	aStream nextPut: 0.	aStream nextPut: 0"options".	^self! !!PostgreSQLP3FrontendMessage methodsFor: 'message'!sync: aStream	aStream nextPutAll: (self bytesFromString: 'S').	aStream nextPutAll: (self bytes32FromNumber: 4).	^self! !!PostgreSQLP3FrontendMessage methodsFor: 'message'!terminate: aStream	aStream nextPutAll: (self bytesFromString: 'X').	aStream nextPutAll: (self bytes32FromNumber: 4).	^self! !!PostgreSQLP3FrontendMessage methodsFor: 'emitting'!bytes16FromNumber: aNumber	^self makeByteFromInt: aNumber bit: 16! !!PostgreSQLP3FrontendMessage methodsFor: 'emitting'!bytes32FromNumber: aNumber	^self makeByteFromInt: aNumber bit: 32! !!PostgreSQLP3FrontendMessage methodsFor: 'emitting'!bytes8FromNumber: aNumber	^self makeByteFromInt: aNumber bit: 8! !!PostgreSQLP3FrontendMessage methodsFor: 'emitting' stamp: 'a 3/26/2017 01:15'!bytesFromString: aString	"In Squeak, you can use utf8 only."	^(String canUnderstand: #asByteArrayEncoding:)		ifTrue: "For VisualWorks"			[aString perform: #asByteArrayEncoding: with: (encoding ifNil: [#'UTF-8'])]		ifFalse: "For Squeak"			[(aString perform: #squeakToUtf8) asByteArray]! !!PostgreSQLP3FrontendMessage methodsFor: 'emitting'!makeByteFromInt: aNumber bit: aSize	| sourceNumber length byteArray |	sourceNumber := aNumber.	length := aSize / 8.	byteArray := ByteArray new: length.	length		to: 1		by: -1		do: 			[:index | 			byteArray at: index put: (sourceNumber bitAnd: 255).			sourceNumber := sourceNumber bitShift: -8].	^byteArray! !!PostgreSQLP3FrontendMessage methodsFor: 'emitting' stamp: 'a 3/26/2017 01:34'!sendPacket: aMessageClass	"For Squeak only"	| message aStream |	logger frontendLog: aMessageClass.	messageClass := aMessageClass.	message := (self class messageIdentificationClassAt: aMessageClass ifAbsent: [PostgreSQLP3UnsupportedFeature raise]).	aStream := WriteStream on: ByteArray new.	self perform: message with: aStream.	socket sendData: aStream contents.	^self! !!PostgreSQLP3FrontendMessage methodsFor: 'instance creation'!socket: aSocket	socket := aSocket.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PostgreSQLP3FrontendMessage class	instanceVariableNames: ''!!PostgreSQLP3FrontendMessage class methodsFor: 'value translation private'!stringFrom: aValue	| aClass |	(aValue isKindOf: Boolean) ifTrue: [^aValue printString].	(aValue isKindOf: Circle) ifTrue: [^self stringFromCircle: aValue].	(aValue isKindOf: Date) ifTrue: [^aValue printFormat: #(3 2 1 $- 1 1)].	(aValue isKindOf: FixedPoint) ifTrue: [^self stringFromFixedPoint: aValue].	(aValue isKindOf: LineSegment) ifTrue: [^self stringFromLineSegment: aValue].	(aValue isKindOf: Point) ifTrue: [^self stringFromPoint: aValue].	(aValue isKindOf: Rectangle) ifTrue: [^self stringFromRectangle: aValue].	(aValue isKindOf: String) ifTrue: [^aValue].	(aValue isKindOf: Text) ifTrue: [^aValue asString].	(aValue isKindOf: Time) ifTrue: [^aValue printString].	(aValue isKindOf: self compatibileTimestampClass) ifTrue: [^self stringFromTimestamp: aValue].	(Symbol canUnderstand: #asQualifiedReference) "For VisualWOrks"		ifTrue: 			[aClass := #Polyline perform: #asQualifiedReference.			(aValue isKindOf: aClass) ifTrue: [^self stringFromPolyline: aValue]].	^aValue printString! !!PostgreSQLP3FrontendMessage class methodsFor: 'value translation private'!stringFromCircle: aValue	^'< ( ', 	aValue center x printString, 	' , ',	aValue center y printString, 	' ) , ',	aValue radius printString,	' >'! !!PostgreSQLP3FrontendMessage class methodsFor: 'value translation private'!stringFromFixedPoint: aValue	^NumberPrintPolicy print: aValue 		using: ('#.', (String new: aValue scale withAll: $#))! !!PostgreSQLP3FrontendMessage class methodsFor: 'value translation private'!stringFromLineSegment: aValue	^'((', 		aValue start x printString, 		',', 		aValue start y printString, 		'),(', 		aValue end x printString, 		',', 		aValue end y printString, 		'))'! !!PostgreSQLP3FrontendMessage class methodsFor: 'value translation private'!stringFromPoint: aValue	^'( ', 	aValue x printString, 	' , ',	aValue y printString, 	' )'! !!PostgreSQLP3FrontendMessage class methodsFor: 'value translation private'!stringFromPolyline: aValue	| anArray |	anArray := aValue vertices				collect: [:each | '(' , each x printString , ',' , each y printString , ')'].	^anArray isEmpty 		ifTrue: ['()']		ifFalse: ['(', (anArray fold: [:val1 :val2 | val1, ',', val2]), ')']! !!PostgreSQLP3FrontendMessage class methodsFor: 'value translation private'!stringFromRectangle: aValue	^'((', 		aValue origin x printString, 		',', 		aValue origin y printString, 		'),(', 		aValue corner x printString, 		',', 		aValue corner y printString, 		'))'! !!PostgreSQLP3FrontendMessage class methodsFor: 'value translation private'!stringFromTimestamp: aValue	| nSec |	nSec := (aValue class canUnderstand: #asTimestamp)		ifTrue: [aValue perform: #nanosecond"VisualWorks"]		ifFalse: [aValue perform: #nanoSecond"Squeak"].	^aValue year printString,	'-',	(('0', aValue month printString) last: 2),	'-',	(('0', aValue days printString) last: 2),	' ',	(('0', aValue hours printString) last: 2),	':',	(('0', aValue minutes printString) last: 2),	':',	(('0', aValue seconds printString) last: 2),	'.',	(('000', nSec printString) last: 3)! !!PostgreSQLP3FrontendMessage class methodsFor: 'value translation private'!stringFromTwoPoint: aValue	^'((', 		aValue origin x printString, 		',', 		aValue origin y printString, 		'),(', 		aValue corner x printString, 		',', 		aValue corner y printString, 		'))'! !!PostgreSQLP3FrontendMessage class methodsFor: 'constants'!versionNumber	"(3 bitShift:16) + 0 ="	^196608! !!PostgreSQLP3FrontendMessage class methodsFor: 'testing'!compatibileTimestampClass	^(Time canUnderstand: #asTimestamp)		ifTrue: [(Time now perform: #asTimestamp) class"VisualWOrks"]		ifFalse: [(Time now perform: #asTimeStamp) class"Squeak"]! !!PostgreSQLP3FrontendMessage class methodsFor: 'instance creation'!socket: aSocket	^self basicNew socket: aSocket! !!PostgreSQLP3FrontendMessage class methodsFor: 'private'!messageIdentificationClassAt: aClass ifAbsent: aBlock	^(aClass isKindOf: Symbol) 		ifTrue: [(aClass, ':') asSymbol]		ifFalse: 			[(aClass class class canUnderstand: #messageMethod)				ifTrue: [aClass class perform: #messageMethod]				ifFalse: [aBlock value]]	"	BindMessageP3 -> #bind:	CloseMessageP3 -> #close:	ConnectionParameterSetP3 -> #startupMessage:	CopyDataMessageP3 -> #copyData:	DescribeMessageP3 -> #describe:	ExecuteMessageP3 -> #execute:	ParseMessageP3 -> #parse:	PasswordMessageP3 -> #passwordMessage:	QueryMessageP3 -> #query:	FunctionCallMessageP3 -> #functionCall:	"! !PostgreSQLP3Error subclass: #PostgreSQLP3HexStringError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!Error subclass: #PostgreSQLP3NoticeResponse	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!PostgreSQLP3NoticeResponse commentStamp: 'ty 2/26/2017 15:41' prior: 0!Exceptions that should be handled for NoticeResponse!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PostgreSQLP3NoticeResponse class	instanceVariableNames: ''!!PostgreSQLP3NoticeResponse class methodsFor: 'testing'!mayResume	"^true 	My instances are all notification responses, which mean that they 	are reporting interesting, rather than critical things. This means it's 	always OK to resume if one of my instances it thrown."	^true! !Error subclass: #PostgreSQLP3NotificationResponse	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!PostgreSQLP3NotificationResponse commentStamp: 'ty 2/26/2017 15:41' prior: 0!Exceptions that should be handled for NotificationResponse!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PostgreSQLP3NotificationResponse class	instanceVariableNames: ''!!PostgreSQLP3NotificationResponse class methodsFor: 'testing'!mayResume	"^true 	My instances are all notification responses, which mean that they 	are reporting interesting, rather than critical things. This means it's 	always OK to resume if one of my instances it thrown."	^true! !Object subclass: #PostgreSQLP3QueryResult	instanceVariableNames: 'parameterDescription completedResponses request rowDescription rows'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!PostgreSQLP3QueryResult commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	completedResponses	<Set>	PostgreSQLP3BackendMessage.  Message: commandComplete:	parameterDescription	<ParameterDescriptionP3>	request	<PostgreSQLP3Connection>	rowDescription	<RowDescriptionP3>	rows	<(OrderedCollection of: (DataRowP3)>!!PostgreSQLP3QueryResult methodsFor: 'initialize-release'!for: aRequestMessageFlow 	"^self 	I initialize myself to represent the results of executing aRequest. I 	read the results from aMessageStream."	request := aRequestMessageFlow.	request backend receivePacketSetInto: self.	^self! !!PostgreSQLP3QueryResult methodsFor: 'accessing'!addCompletedResponse: aCompletedResponse 	"^selfI add aCompletedResponse to my collection of completed responses.  If a given query string contains a number of actions (either implicit or explicit), there will be a CompletedResponse for each."	self completedResponses add: aCompletedResponse.	^self! !!PostgreSQLP3QueryResult methodsFor: 'accessing'!completedResponses	"^a SetI return mu collection of CompletedResponses.  There should be one for every implicit or explicit command in the query string sent to the back end."	completedResponses isNil ifTrue: [completedResponses := Set new].	^completedResponses! !!PostgreSQLP3QueryResult methodsFor: 'accessing'!connection	"^a PostgreSQLConnection 	I return the connection I'm a result for."	^self request connection! !!PostgreSQLP3QueryResult methodsFor: 'accessing'!parameterDescription	^parameterDescription! !!PostgreSQLP3QueryResult methodsFor: 'accessing'!parameterDescription: aValue	parameterDescription := aValue! !!PostgreSQLP3QueryResult methodsFor: 'accessing'!request	"^a PostgreSQLRequest	I return the request I represent a result for."	^request! !!PostgreSQLP3QueryResult methodsFor: 'accessing'!rowDescription	"^self 	I return my row description. This describes what will be found in 	each row returned by the back end. This description is made up of a 	number of field descriptions, which in turn identify the name, object 	ID, type size and type odifier for each field."	^rowDescription! !!PostgreSQLP3QueryResult methodsFor: 'accessing'!rowDescription: aRowDescription 	"^self 	I record my row description. c.f. self>>rowDescription."	rowDescription := aRowDescription.	^self! !!PostgreSQLP3QueryResult methodsFor: 'accessing'!rows	"^an OrderedCollection 	I return my collection of rows."	rows isNil ifTrue: [rows := OrderedCollection new].	^rows! !!PostgreSQLP3QueryResult methodsFor: 'testing'!isReadyForQuery	"^a Booean 	I return true is I don't have any query response stuff, otherwise I return false. This is an ugly way 	of doing things until I get a message stream going."	^self completedResponses isEmpty! !!PostgreSQLP3QueryResult methodsFor: 'services'!valueAt: rowIndex ofColumn: aColumnIndex 	"^a Symbol 	I return the type of data in the column identified by aColumnIndex."	| typeID columnTypeName aString |	typeID := (self rowDescription fieldDescriptions at: aColumnIndex) objectID.	columnTypeName := self connection dataTypeTable at: typeID.	aString := ((self rows at: rowIndex) fields at: aColumnIndex) ifNil: [^nil] ifNotNil: #asString.	^self class translationsFromPostgres: columnTypeName value: aString readStream! !!PostgreSQLP3QueryResult methodsFor: 'private'!backendLog: aMessages	request backendLog: aMessages! !!PostgreSQLP3QueryResult methodsFor: 'private'!readStream	"^a ReadStream 	I return the stream from which I can read results. This is the read stream of my request."	^self request readStream! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PostgreSQLP3QueryResult class	instanceVariableNames: ''!!PostgreSQLP3QueryResult class methodsFor: 'value translation private'!fromPointBlock	"^a Block 	I return the block that can pull a Point from a stream, where that stream contains a string in the form 	defined for the PostgreSQL type 'point'."	^	[:aSession :aStream | 	| x y |	aStream upTo: $(.	x := (aStream upTo: $,) asNumber.	y := (aStream upTo: $)) asNumber.	Point x: x y: y]! !!PostgreSQLP3QueryResult class methodsFor: 'instance creation'!for: aRequest 	"^a PostgreSQLRequestResult 	I return a new instance of myself which represents the results of 	executing aRequest."	^self new for: aRequest! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!boolBlock: aStream	^aStream next == $t! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!boxBlock: aStream	"^a Block 	I return the block that can pull a Rectangle from a stream, where that stream contains a string in the 	form defined for the PostgreSQL type 'box'. The block returns a Rectangle."	| originPoint cornerPoint |	originPoint := self fromPointBlock value: ((aStream upTo: $)), ')') readStream.	aStream upTo: $,.	cornerPoint := self fromPointBlock value: ((aStream upTo: $)), ')') readStream.	^Rectangle origin: originPoint corner: cornerPoint! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!bpcharBlock: aStream	^aStream contents! !!PostgreSQLP3QueryResult class methodsFor: 'value translation' stamp: 'a 3/28/2017 00:22'!byteaBlock: aStream	"^a ByteArray 	I return a ByteArray created from the contents of aStream in the context of aSession.	As of version 9 of PostgreSQL bytea values could be returned on one of two forms.   From section 8.4 of the PostgreSQL 9.0 manual:        	The bytea type supports two external formats for input and output: PostgreSQL's historical		'escape' format, and 'hex' format.  ... the default is hex.		... The 'hex' format encodes binary data as 2 hexadecimal digits per byte, most significant		nibble first. The entire string is preceded by the sequence \x "	| aString |	(aStream size > 1 and: [(aStream next: 2) = '\x'])		ifTrue: 			[aString := aStream upToEnd.			aString size even 				ifFalse: 					[PostgreSQLP3HexStringError 						compatibleRaiseSignal: 'Hex strings must have an even number of characters'].			^ByteArray fromHexString: aString asUppercase]		ifFalse: 			[aStream reset.			^aStream]! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!charBlock: aStream	^aStream contents! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!cidrBlock: aStream	^aStream contents! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!circleBlock: aStream	"^a Block 	I return the block that can pull a Circle from a stream, where that stream contains a string in the 	form defined for the PostgreSQL type 'circle'. The block returns a Circle."	| center radius |	aStream upTo: $<.	center := self fromPointBlock value: (aStream upTo: $)) readStream.	aStream upTo: $,.	radius := (aStream upTo: $>) asNumber.	^Circle center: center radius: radius! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!dateBlock: aStream	"^a Block 	I return the block that can pull a Date from a stream, where that stream contains a string in the 	form defined for the PostgreSQL type 'date'. The block returns a Date."	| year monthIndex day |	year := (aStream upTo: $-) asNumber.	monthIndex := (aStream upTo: $-) asNumber.	day := aStream upToEnd asNumber.	(Date class canUnderstand: #newDay:monthNumber:year:)		ifTrue:			[^Date perform: #newDay:monthNumber:year:				with: day				with: monthIndex				with: year]		ifFalse:			[^Date				newDay: day				month: monthIndex				year: year]! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!float4Block: aStream	^(aStream contents , 'd') asNumber! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!float8Block: aStream	^(aStream contents , 'd') asNumber! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!inetBlock: aStream	^aStream contents! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!int2Block: aStream	^aStream contents asNumber! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!int4Block: aStream	^aStream contents asNumber! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!int8Block: aStream	^aStream contents asNumber! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!integerBlock: aStream	^aStream asNumber! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!intervalBlock: aStream	"^a Block 	I return the block that can pull an interval from a stream, where that stream contains a string in the 	form defined for the PostgreSQL type 'interval'. The block returns the integer number of seconds in 	the 	interval."	| totalSeconds |	totalSeconds := (aStream upTo: $ ) asNumber * 86400.	totalSeconds := totalSeconds + ((aStream upTo: $:) asNumber * 3600).	totalSeconds := totalSeconds + ((aStream upTo: $:) asNumber * 60).	^totalSeconds + aStream upToEnd asNumber! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!lsegBlock: aStream	"^a Block 	I return the block that can pull a LineSegment from a stream, where that stream contains a string in 	the form defined for the PostgreSQL type 'lseg'. The block returns a LineSegment."	| start end |	aStream upTo: $[.	start := self fromPointBlock value: (aStream upTo: $)) readStream.	end := self fromPointBlock value: (aStream upTo: $]) readStream.	^LineSegment from: start to: end! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!macaddrBlock: aStream	^aStream contents! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!nameBlock: aStream	^aStream contents! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!numericBlock: aStream	| num scale arr |	num := (aStream contents , 's') asNumber.	(num isKindOf: Float)		ifTrue: "For Squeak"			[arr := ((aStream contents, '.') tokensBasedOn: $.).			scale := (arr at: 2) size.			num := Fraction numerator: (arr first, (arr at: 2)) denominator: 10 ** scale].	^num! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!oidBlock: aStream	^aStream contents asNumber! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!pathBlock: aStream	"^a Block 	I return the block that can pull a Polyline from a stream, where that stream contains a string in the 	form defined for the PostgreSQL type 'path'. The block returns a Polyline. The format of the string is 	'((x,y),(x,y) ...)' for closed paths, and '[(x,y),(x,y) ...]' for open paths. I don't really care because I 	make them both onto a Polyline."	| vertices |	vertices := OrderedCollection new.	aStream skip: 1.	aStream upTo: $(.	[aStream atEnd]		whileFalse: 			[aStream skip: -1.			vertices add: (self fromPointBlock value: (aStream upTo: $)) readStream).			aStream upTo: $(].	^#Polyline asQualifiedReference value perform: #vertices: with: vertices asArray! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!pointBlock: aStream	"^a Block 	I return the block that can pull a Point from a stream, where that stream contains a string in the form 	defined for the PostgreSQL type 'point'."	| x y |	aStream upTo: $(.	x := (aStream upTo: $,) asNumber.	y := (aStream upTo: $)) asNumber.	^Point x: x y: y! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!polygonBlock: aStream	^self pathBlock: aStream! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!regprocBlock: aStream	^aStream contents! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!textBlock: aStream	^aStream contents! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!timeBlock: aStream	^Time readFrom: aStream! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!timestampBlock: aStream	| date time microseconds aClass dt |	date := self dateBlock: (aStream upTo: $ ) readStream.	time := self timeBlock: (aStream upTo: $.) readStream.	microseconds := (aStream upToEnd , '000000' first: 6) asNumber.	(Time canUnderstand: #asTimestamp)		ifTrue: "For VisualWorks"			[aClass := (Time now perform: #asTimestamp) class.			dt := aClass perform: #fromDate:andTime: with: date with: time.			^aClass perform: #fromMicroseconds: with: dt asSeconds * 1000000 + microseconds]		ifFalse:			[aClass := (Time now perform: #asTimeStamp) class.			^aClass perform: #date:time: with: date with: time]! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!timestamptzBlock: aStream	| simpleTimestampStream |	simpleTimestampStream := WriteStream on: String new.	simpleTimestampStream nextPutAll: (aStream upTo: Character space).	simpleTimestampStream nextPut: Character space.		[aStream atEnd or: 			[| nextCharacter |			nextCharacter := aStream peek.			nextCharacter == $+ or: [nextCharacter == $-]]]			whileFalse: [simpleTimestampStream nextPut: aStream next].	^self timestampBlock: simpleTimestampStream contents readStream! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!translationsFromPostgres: columnTypeName value: aStream	^self perform: (columnTypeName, 'Block:') asSymbol with: aStream! !!PostgreSQLP3QueryResult class methodsFor: 'value translation'!varcharBlock: aStream	^aStream contents! !Error subclass: #PostgreSQLP3SuspendedResponse	instanceVariableNames: 'result'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!PostgreSQLP3SuspendedResponse commentStamp: 'ty 2/26/2017 15:41' prior: 0!The exception that should be handled when a Portal is suspended for reached maximum number of rows to returnInstance Variables	result	<PostgreSQLP3QueryResult>!!PostgreSQLP3SuspendedResponse methodsFor: 'accessing'!result	^result! !!PostgreSQLP3SuspendedResponse methodsFor: 'accessing'!result: queryResult	result := queryResult! !PostgreSQLP3Error subclass: #PostgreSQLP3UnexpectedMessage	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!PostgreSQLP3Error subclass: #PostgreSQLP3UnsupportedFeature	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!PostgreSQLP3UnsupportedFeature commentStamp: 'ty 2/26/2017 15:41' prior: 0!The exceptions that is not handled.!Object subclass: #QueryMessageP3	instanceVariableNames: 'queryString'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!QueryMessageP3 commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	queryString	<String>	QueryString!!QueryMessageP3 methodsFor: 'accessing'!queryString	"^a String 	I return the string containing the query I am to send to the server."	queryString isNil ifTrue: [queryString := String new].	^queryString! !!QueryMessageP3 methodsFor: 'accessing'!queryString: aString 	"^self 	I record the string containing the query I am to send to the server."	queryString := aString.	^self! !!QueryMessageP3 methodsFor: 'printing'!printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	aStream nextPutAll: '>>>>>'; tab.	aStream nextPutAll: self class name.	aStream cr.	aStream nextPutAll: 'Query string: '.	(queryString first: 100) printOn: aStream.	aStream cr.	^self! !!QueryMessageP3 methodsFor: 'initialize-release'!query: aString	"I create instanse of QueryMessage for Simple Query."	self queryString: aString.	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!QueryMessageP3 class	instanceVariableNames: ''!!QueryMessageP3 class methodsFor: 'message handling'!messageMethod	^#query:! !!QueryMessageP3 class methodsFor: 'instance creation'!query: aString	"I create instanse of QueryMessage for Simple Query."	^self basicNew query: aString! !Object subclass: #RowDescriptionP3	instanceVariableNames: 'fieldDescriptions'	classVariableNames: ''	poolDictionaries: ''	category: 'PostgresP3'!!RowDescriptionP3 commentStamp: 'ty 2/26/2017 15:41' prior: 0!Instance Variables	fieldDescriptions	<FieldDescriptionP3>!!RowDescriptionP3 methodsFor: 'accessing'!fieldDescriptions	"^an OrderedCollection 	I return my collection of field descriptions."	fieldDescriptions isNil ifTrue: [fieldDescriptions := OrderedCollection new].	^fieldDescriptions! !!RowDescriptionP3 methodsFor: 'accessing'!numberOfFields	"^an Integer 	I return the number of field descriptions I have."	^self fieldDescriptions size! !!RowDescriptionP3 methodsFor: 'printing'!printOn: aStream 	"^self 	I return a string representation of myself. This string is intended to 	aid developers, and is not a critical part of the library."	aStream nextPutAll: '>>>>>'; tab.	aStream nextPutAll: self class name.	aStream cr.	fieldDescriptions printOn: aStream.	aStream cr.	^self! !!RowDescriptionP3 methodsFor: 'services'!indexOfName: aString 	"^an IntegerI return the index of the field named aString."	| index |	index := 0.	self fieldDescriptions do: 			[:aFieldDescription | 			index := index + 1.			aFieldDescription name = aString ifTrue: [^index]].	^nil! !