<?xml version="1.0"?><st-source><!-- Name: QRCodePackageName: QRCodeParcel: #('QRCode')ParcelDirectory: QRCodeParcelName: QRCodeVersion: 7.10Date: 12:25:44 AM September 25, 2018 --><time-stamp>From VisualWorks® Personal Use Edition, 7.10 of 2013年7月10日 on 2018年9月25日 at 0:25:44</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>QRBinaryWriteStream</name><environment>Core</environment><super>Core.WriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bitPosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QRCode</package></attributes></class><class><name>QRBinaryReadStream</name><environment>Core</environment><super>Core.ReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bitPosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QRCode</package></attributes></class><class><name>QRCodeGenerator</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>data errorCorrectionLevel mode encoding version quietZone mask </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QRCode</package></attributes></class><class><name>QRImageWriteStream</name><environment>Core</environment><super>Core.QRBinaryWriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cellSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>QRCode</package></attributes></class><methods><class-id>Core.QRBinaryWriteStream</class-id> <category>accessing</category><body package="QRCode">bitPosition	^bitPosition</body><body package="QRCode">nextPut: byte fill: size	| rem |	(byte = 0 and: [size = 0]) ifTrue: [^self].	bitPosition = 8		ifTrue:			[self nextPut: (byte bitShift: (8 - size)).			rem := size - 8.			bitPosition := size min: 8]		ifFalse:			[collection at: position put: ((collection at: position) bitOr: (byte bitShift: (8 - bitPosition - size))).			rem := size - 8 + bitPosition.			bitPosition := bitPosition + size min: 8].	rem &lt;= 0 ifTrue: [^self].	self nextPut: (byte bitAnd: ((1 bitShift: rem) - 1)) fill: rem</body><body package="QRCode">nextPutAll: byteArray	byteArray do:		[:byte |		self nextPut: byte fill: 8]</body><body package="QRCode">size	^(position * 8) - 8 + bitPosition</body></methods><methods><class-id>Core.QRBinaryWriteStream</class-id> <category>private</category><body package="QRCode">on: aCollection	super on: aCollection.	bitPosition := 8</body></methods><methods><class-id>Core.QRBinaryWriteStream class</class-id> <category>instance creation</category><body package="QRCode">new: size	^self on: (ByteArray new: size)</body></methods><methods><class-id>Core.QRBinaryReadStream</class-id> <category>private</category><body package="QRCode">on: aCollection	super on: aCollection.	bitPosition := 0.</body></methods><methods><class-id>Core.QRBinaryReadStream</class-id> <category>accessing</category><body package="QRCode">nextBit	| byte |	bitPosition = 0		ifTrue: 	[byte := self next]		ifFalse: [byte := collection at: position].	bitPosition := bitPosition + 1.	^[(byte bitShift: bitPosition - 8) bitAnd: 1]		ensure: [bitPosition := bitPosition bitAnd: 7]</body></methods><methods><class-id>Core.QRBinaryReadStream</class-id> <category>testing</category><body package="QRCode">atEnd	super atEnd ifFalse: [^false].	^bitPosition = 0</body></methods><methods><class-id>Core.QRCodeGenerator</class-id> <category>accessing</category><body package="QRCode">data	^data</body><body package="QRCode">data: aData	data := aData</body><body package="QRCode">encoding	^encoding</body><body package="QRCode">encoding: anEncoding	encoding := anEncoding</body><body package="QRCode">errorCorrectionLevel	^errorCorrectionLevel</body><body package="QRCode">errorCorrectionLevel: lmqh	(#(#L #M #Q #H) includes: lmqh)		ifFalse: [^Error raiseErrorString: '#L , #M, #Q or #H should be given.'].	errorCorrectionLevel := lmqh</body><body package="QRCode">mode	^mode</body><body package="QRCode">mode: aMode	(#(#digit #alphaNumeric #kanji #eightBit) includes: aMode)		ifFalse: [^Error raiseErrorString: '#digit , #alphaNumeric, #kanji or #eightBit should be given.'].	mode := aMode</body><body package="QRCode">quietZone	^quietZone</body><body package="QRCode">quietZone: aSize	(aSize &gt;= 0 and: [aSize // 1 = aSize])		ifFalse: [^Error raiseErrorString: 'Positive integer should be given.'].	quietZone := aSize</body><body package="QRCode">version	^version</body><body package="QRCode">version: aNumber	((aNumber between: 1 and: 40) and: [aNumber // 1 = aNumber])		ifFalse: [^Error raiseErrorString: 'Positive integer from 1 to 40 should be given.'].	version := aNumber</body></methods><methods><class-id>Core.QRCodeGenerator</class-id> <category>private-error-correction</category><body package="QRCode">divideByPolynomial: bytes by: polynomial	| temp gx str |	temp := bytes.	bytes size timesRepeat:		[temp first = 0			ifTrue: [temp := temp allButFirst: 1]			ifFalse:				[gx := polynomial collect: [:each | self getInteger: (each + (self getExponent: temp first))].				str := WriteStream on: (ByteArray new: (temp size max: gx size) -1).				2 to: (temp size max: gx size) do:					[:idx |					(temp size &gt;= idx and: [gx size &gt;= idx])						ifTrue:							[str nextPut: ((temp at: idx) bitXor: (gx at: idx))]						ifFalse:							[temp size &gt;= idx								ifTrue: [str nextPut: (temp at: idx)]								ifFalse: [str nextPut: (gx at: idx)]]].				temp := str contents]].	^temp</body><body package="QRCode">getErrorCorrectionCode: bytes	| info polynomial arr1 arr2 idx target byteArray |	info := self class dataBlockTable at: (version printString, errorCorrectionLevel) asSymbol.	polynomial := self class generatingPolynomialTable at: ((info at: 2) - (info at: 3)).	arr1 := OrderedCollection new: (info at: 1) + (info at: 4).	arr2 := OrderedCollection new: (info at: 1) + (info at: 4).	idx := 1.	(info at: 1) timesRepeat:		[target := bytes copyFrom: idx to: idx + (info at: 3) - 1.		arr1 add: target.		arr2 add: (self divideByPolynomial: target by: polynomial).		idx := idx + (info at: 3)].	info last = 0		ifFalse:			[polynomial := self class generatingPolynomialTable at: ((info at: 5) - (info at: 6)).			(info at: 4) timesRepeat:				[target := bytes copyFrom: idx to: idx + (info at: 6) - 1.				arr1 add: target.				arr2 add: (self divideByPolynomial: target by: polynomial).				idx := idx + (info at: 6)]].	byteArray := WriteStream on: (ByteArray new: ((info at: 1) * (info at: 2)) + ((info at: 4) * (info at: 5))).	arr1 := arr1 collect: [:each | each readStream].	[arr1 last atEnd]		whileFalse:			[arr1 do:				[:str |				str atEnd ifFalse: [byteArray nextPut: str next]]].	arr2 := arr2 collect: [:each | each readStream].	[arr2 last atEnd]		whileFalse:			[arr2 do:				[:str |				str atEnd ifFalse: [byteArray nextPut: str next]]].	^byteArray contents</body><body package="QRCode">getExponent: anIndex	^self class toExponentTable at: anIndex</body><body package="QRCode">getInteger: anIndex	anIndex \\ 255 = 0		ifTrue: [^1]		ifFalse: [^self class toIntegerTable at: anIndex \\ 255]</body></methods><methods><class-id>Core.QRCodeGenerator</class-id> <category>make-image</category><body package="QRCode">expandQuietZone: bits	| cellSize orgWidthUnit expWidthUnit arr |	cellSize := self class cellSizeTable at: version.	quietZone = 0		ifTrue: [arr := bits]		ifFalse:			[orgWidthUnit := ((cellSize // 32) + 1).			expWidthUnit := ((cellSize + quietZone + quietZone // 32) + 1).			arr := QRBinaryWriteStream new: (expWidthUnit * 32 / 8 *  (cellSize + quietZone + quietZone)).			arr nextPut: 0 fill: expWidthUnit * 32 * quietZone + quietZone.			1 to: bits size by: orgWidthUnit * 4 do:				[:idx |				arr nextPutAll: (bits copyFrom: idx to: idx + (orgWidthUnit * 4) - 1).				orgWidthUnit &lt; expWidthUnit ifTrue: [arr nextPut: 0 fill: (expWidthUnit - orgWidthUnit) * 32]].			arr nextPut: 0 fill: expWidthUnit * 32 * quietZone - quietZone.			arr := arr contents.			cellSize := cellSize + quietZone + quietZone].	"Make image"	^Image extent: cellSize @ cellSize depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: arr</body><body package="QRCode">getAllPatternMaskedImage	| cellSize line arr image pattern pre alignBitsFirst alignBitsOther alignBitsLast |	cellSize := self class cellSizeTable at: version.	line := QRImageWriteStream newCell: cellSize.	arr := QRImageWriteStream newCell: cellSize.	"Horizontal alignment pattern bits"	pattern := ((self class alignmentPatternTable at: version) collect: [:each | each - 1 to: each + 3]) asList.	pre := 0.	(pattern allButLast: 1) do: 		[:each |		line nextPut: 0 fill: each first - 1 - pre; nextPut: 2r11111 fill: 5.		pre := each last].	line fillToEOL.	alignBitsFirst := line contents.	line reset.	pre := 0.	pattern do: 		[:each |		line nextPut: 0 fill: each first - 1 - pre; nextPut: 2r11111 fill: 5.		pre := each last].	line fillToEOL.	alignBitsOther := line contents.	line reset.	pre := 0.	(pattern allButFirst: 1)  do: 		[:each |		line nextPut: 0 fill: each first - 1 - pre; nextPut: 2r11111 fill: 5.		pre := each last].	line fillToEOL.	alignBitsLast := line contents.	line reset.	1 to: cellSize do:		[:idx |		"Upper finder pattern and Version Information"		idx &lt;= 6			ifTrue:				[version &lt; 7					ifTrue: [line nextPut: 2r111111111 fill: 9; nextPut: 0 fill: cellSize - 17; nextPut: 2r11111111 fill: 8; fillToEOL]					ifFalse: [line nextPut: 2r111111111 fill: 9; nextPut: 0 fill: cellSize - 20; nextPut: 2r11111111111 fill: 11; fillToEOL]].		idx = 7			ifTrue:				["Upper finder pattern at last and Horizontal timing pattern"				cellSize timesRepeat: [line nextPut: 1 fill: 1].				line fillToEOL].		(idx = 8 or: [idx = 9])			ifTrue:				["Under Upper finder pattern and 	FormatInformation"				line nextPut: 2r111111111 fill: 9; nextPut: 0 fill: cellSize - 17; nextPut: 2r11111111 fill: 8; fillToEOL].		(idx between: 10 and: (cellSize - 11))			ifTrue:				["Vertical timing pattern"				line nextPut: 2r00000010 fill: 8; fillToEOL].		(idx between: (cellSize - 10) and: (cellSize - 8))			ifTrue:				["Vertical timing pattern and Version Information"				version &lt; 7					ifTrue: [line nextPut: 2r00000010 fill: 8; fillToEOL]					ifFalse: [line nextPut: 2r11111110 fill: 8; fillToEOL]].		idx &gt;= (cellSize - 7)			ifTrue:				["Lower finder pattern and Dark module"				line nextPut: 2r111111111 fill: 9; fillToEOL].		"Mask alignment pattern"		(pattern notEmpty and: [pattern first includes: idx])			ifTrue: 				[| alignBits |				(idx between: 5 and: 9)					ifTrue: [alignBits := alignBitsFirst]					ifFalse: 						[pattern size = 1							ifTrue: [alignBits := alignBitsLast]							ifFalse: [alignBits := alignBitsOther]].				line contents keysAndValuesDo: [:i :val | arr nextPut: (val bitOr: (alignBits at: i)) fill: 8]]			ifFalse: [arr nextPutAll: line contents].		(pattern notEmpty and: [pattern first last &lt; idx]) ifTrue: [pattern removeFirst].		line reset].	image := Image extent: cellSize @ cellSize depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: arr contents.	^image</body><body package="QRCode">maskAlignmentPattern: image	"Points are the zero based"	| pattern skip |	version = 1 ifTrue: [^self].	pattern := self class alignmentPatternTable at: version.	skip := Array with: ((pattern first) @ (pattern first))				with: ((pattern first) @ (pattern last))				with: ((pattern last) @ (pattern first)).	pattern do:		[:x |		pattern do:			[:y | 			(skip includes: y @ x)				ifFalse: 					[image atPoint: ((y-1)@(x-1)) put: 0.					image atPoint: ((y-1)@x) put: 0.					image atPoint: ((y-1)@(x+1)) put: 0.					image atPoint: (y@(x-1)) put: 0.					image atPoint: (y@(x+1)) put: 0.					image atPoint: ((y+1)@(x-1)) put: 0.					image atPoint: ((y+1)@x) put: 0.					image atPoint: ((y+1)@(x+1)) put: 0]]]</body><body package="QRCode">placeData: bits	| cellSize basePallete dataStream toggle |	cellSize := self class cellSizeTable at: version.	basePallete := self getAllPatternMaskedImage.	dataStream := QRBinaryReadStream on: bits.	toggle := true.	cellSize to: 2 by: -2 do:		[:each | | orgX interval |		each &lt;= 7			ifTrue: [orgX := each - 1]			ifFalse: [orgX := each ].		toggle			ifTrue: [interval := cellSize - 1 to: 0 by: -1] "Zero based"			ifFalse: [interval := 0 to: cellSize - 1 by: 1]. "Zero based"		toggle := toggle not.		interval do:			[:y | | |			orgX -1 to: orgX - 2 by: -1 do: "Zero based"				[:x |				(basePallete atPoint: x @ y) = 0					ifTrue: 						[(dataStream atEnd not and: [(dataStream nextBit) = 1])							ifTrue: [basePallete atPoint: x @ y put: 1]]]]].	^basePallete bits</body></methods><methods><class-id>Core.QRCodeGenerator</class-id> <category>private-data</category><body package="QRCode">toBinaryFromAlphaNumeric: stream	| num table |	table := self class alphaNumericTable.	1 to: (data size // 2 * 2) by: 2 do:		[:idx |		num := ((table at: (data at: idx)) * 45) + (table at: (data at: idx + 1)).		stream nextPut: num fill: 11].	data size odd		ifTrue:			[num := (table at: (data last)).			stream nextPut: num fill: 6]</body><body package="QRCode">toBinaryFromData	| limit code |	limit := self class limitDataLengthTable at: (version printString, errorCorrectionLevel) asSymbol.	code := QRBinaryWriteStream new: limit.	mode == #digit		ifTrue: 			[code nextPut: 2r0001 fill: 4.			(version between: 1 and: 9) ifTrue: [code nextPut: data size fill: 10].			(version between: 10 and: 26) ifTrue: [code nextPut: data fill: 12].			(version between: 27 and: 40) ifTrue: [code nextPut: data fill: 14].			self toBinaryFromDigit: code].	mode == #alphaNumeric		ifTrue: 			[code nextPut: 2r0010 fill: 4.			(version between: 1 and: 9) ifTrue: [code nextPut: data size fill: 9].			(version between: 10 and: 26) ifTrue: [code nextPut: data size fill: 11].			(version between: 27 and: 40) ifTrue: [code nextPut: data size fill: 13].			self toBinaryFromAlphaNumeric: code].	mode == #eightBit		ifTrue: 			[code nextPut: 2r0100 fill: 4.			(version between: 1 and: 9) ifTrue: [code nextPut: data size fill: 8].			(version between: 10 and: 26) ifTrue: [code nextPut: data size fill: 16].			(version between: 27 and: 40) ifTrue: [code nextPut: data size fill: 16].			self toBinaryFromEightBit: code].	mode == #kanji 		ifTrue: 			[code nextPut: 2r1000 fill: 4.			(version between: 1 and: 9) ifTrue: [code nextPut: data size fill: 8].			(version between: 10 and: 26) ifTrue: [code nextPut: data size fill: 10].			(version between: 27 and: 40) ifTrue: [code nextPut: data size fill: 12].			self toBinaryFromKanji: code].	"endPattern"	(limit * 8) - code size &lt; 0 ifTrue: [^Error raiseErrorString: 'Data is too much.'].	code nextPut: 0 fill: (((limit * 8) - code size) min: 4).	"fillBit"	code nextPut: 0 fill: (8 - code bitPosition) .	"fillWord"	1 to: limit - code position do:		[:idx |		idx odd			ifTrue: [code nextPut: 2r11101100 fill: 8]			ifFalse: [code nextPut: 2r00010001 fill: 8]].	^code contents</body><body package="QRCode">toBinaryFromDigit: stream	| num |	1 to: (data size // 3 * 3) by: 3 do:		[:idx |		num := (data copyFrom: idx to: idx + 2) asNumber.		stream nextPut: num fill: 10].	data size \\ 3 = 2 		ifTrue: 			[num := (data last: 2) asNumber.			stream nextPut: num fill: 7].	data size \\ 3 = 1		ifTrue:			[num := (data last: 1) asNumber.			stream nextPut: num fill: 4]</body><body package="QRCode">toBinaryFromEightBit: stream	(data asByteArrayEncoding: encoding) do:		[:num |		stream nextPut: num fill: 8]</body><body package="QRCode">toBinaryFromKanji: stream	| num encoder |	encoder := ShiftJISCharacterEncoder new.	data do:		[:char |		num := encoder encode: char.		(num between: 16r8140 and: 16r9FFC) ifTrue: [num := num - 16r8140].		(num between: 16rE040 and: 16rEBBF) ifTrue: [num := num - 16rC140].		num := ((num bitShift: -8"high bit") * 16rC0) + (num bitAnd: 255"low bit").		stream nextPut: num fill: 13]</body></methods><methods><class-id>Core.QRCodeGenerator</class-id> <category>action</category><body package="QRCode">getBMPArrayMagnify: num	"Store as little engin"	| image bitmapData |	image := self getImage magnifiedBy: num @ num.	bitmapData := WriteStream on: (ByteArray new: (62"bfOffBits" + image bits size)).	bitmapData nextPutAll: 'BM' asByteArray. "bfType"	bitmapData nextPutAll: ((#[0 0 0], (62"bfOffBits" + image bits size) asByteArray) last: 4) reverse. "bfSize"	bitmapData nextPutAll: #[0 0]. "bfReserved1"	bitmapData nextPutAll: #[0 0]. "bfReserved2"	bitmapData nextPutAll: #[62 0 0 0]. "bfOffBits = BITMAPFILEHEADER(14) + BITMAPINFOHEADER(40) + RGBQUAD(8)"	bitmapData nextPutAll: #[40 0 0 0]. "biSize"	bitmapData nextPutAll: ((#[0 0 0], image width asByteArray) last: 4) reverse. "biWidth"	bitmapData nextPutAll: ((#[0 0 0], image height asByteArray) last: 4) reverse. "biHeight"	bitmapData nextPutAll: #[1 0]. "biPlanes"	bitmapData nextPutAll: #[1 0]. "biBitCount"	bitmapData nextPutAll: #[0 0 0 0]. "biCompression(BI_RGB)"	bitmapData nextPutAll: #[0 0 0 0]. "biSizeImage(BI_RGB)"	bitmapData nextPutAll: #[1 0 0 0]. "biXPixPerMeter"	bitmapData nextPutAll: #[1 0 0 0]. "biYPixPerMeter"	bitmapData nextPutAll: #[0 0 0 0]. "biClrUsed"	bitmapData nextPutAll: #[0 0 0 0]. "biClrImportant"	bitmapData nextPutAll: #[255 255 255 0 0 0 0 0]. "rgbquad"	image height  to: 1 by: -1 do:		[:idx |		bitmapData nextPutAll: (image bits copyFrom: (idx-1) * image bits size / image height + 1 to: idx * image bits size / image height)].	^bitmapData contents</body><body package="QRCode">getImage	| bits |	data isNil ifTrue: [^Error raiseErrorString: 'Data is nil.'].	errorCorrectionLevel isNil ifTrue: [errorCorrectionLevel := #M].	encoding isNil ifTrue: [encoding := #default].	self decideMode.	self decideVersion.	quietZone isNil ifTrue: [quietZone := 4].	bits := self toBinaryFromData.	bits := self getErrorCorrectionCode: bits.	bits := self placeData: bits.	bits := self adoptBest: bits.	^self expandQuietZone: bits</body></methods><methods><class-id>Core.QRCodeGenerator</class-id> <category>tool</category><body package="QRCode">decideMode	| tempMode |	(data isKindOf: ByteArray)		ifTrue: [tempMode := #eightBit]		ifFalse:			[(data contains: [:char | char isDigit not])				ifTrue: 					[(data contains: [:char | ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:' includes: char) not])						ifTrue: 							[[((data isKindOf: TwoByteString) and: [(data asByteArrayEncoding: #Shift_JIS) size = data sizeInBytes])								ifTrue: [tempMode := #kanji]								ifFalse: [tempMode := #eightBit]]								on: Error								do: [tempMode := #eightBit]]						ifFalse: [tempMode := #alphaNumeric]]				ifFalse: [tempMode := #digit]].	mode isNil ifTrue: [mode := tempMode].	mode == #digit		ifTrue:			 [(tempMode == #alphaNumeric or: [tempMode == #kanji or: [tempMode == #eightBit]])				ifTrue: [^Error raiseErrorString: 'Data and mode don''t match.']].	mode == #alphaNumeric		ifTrue:			[(tempMode == #kanji or: [tempMode == #eightBit])				ifTrue: [^Error raiseErrorString: 'Data and mode don''t match.']].	mode == #kanji		ifTrue:			[(tempMode == #digit or: [tempMode == #alphaNumeric or: [tempMode == #eightBit]])				ifTrue: [^Error raiseErrorString: 'Data and mode don''t match.']]</body><body package="QRCode">decideVersion	| length arr tempVersion |	(mode == #eightBit and: [(data isKindOf: ByteArray) not])		ifTrue: [length := (data asByteArrayEncoding: encoding) size]		ifFalse: [length := data size].	arr := self class versionTable at: (mode, errorCorrectionLevel) asSymbol.		arr keysAndValuesDo:		[:idx :num |		(length &lt; num)			ifTrue:				[tempVersion := idx.				version isNil					ifTrue: 						[version := tempVersion.						^self]					ifFalse: 						[version &lt; tempVersion 							ifTrue: 	[^Error raiseErrorString: 'Data is too much.']							ifFalse: [^self]]]].	^Error raiseErrorString: 'Data is too much even version 40.'</body></methods><methods><class-id>Core.QRCodeGenerator</class-id> <category>private-mask</category><body package="QRCode">adoptBest: bits	| bestScore bestImage |	bestScore := nil.	self class maskPattern keysDo:		[:idx | | score image |		image := self  getCompletionImageOf: bits with: idx.		score := self calculatePaneltyScore: image.		(score &lt;= (bestScore ifNil: [score]))			ifTrue:				[bestScore := score.				bestImage := image.				mask := idx - 1]].	^bestImage bits</body><body package="QRCode">getCompletionImageOf: bits with: maskPattern	| cellSize temp image |	cellSize := self class cellSizeTable at: version.	temp := WriteStream on: (ByteArray new: bits size).	(self getMaskedBitsOf: bits with: maskPattern) with: (self getAllPatternMaskedImage) bits do:		[:a :b |		temp nextPut: (a bitOr: b)].	image := Image extent: cellSize @ cellSize depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: temp contents.	self maskFinderPattern: image.	self maskAlignmentPattern: image.	self maskFormatInformation: image with: maskPattern.	self maskVersionInformation: image.	^image</body><body package="QRCode">getMaskedBitsOf: bits with: maskPattern	| cycle cellSize pattern stream horizontalBytes cycleStream endOfLine invisibleMask |	cycle := 0.	cellSize := self class cellSizeTable at: version.	pattern := self class maskPattern at: maskPattern.	cycleStream := ReadStream on: (pattern copyFrom: cycle * 4 + 1 to: cycle * 4 + 3).	horizontalBytes := ((cellSize // 32) + 1) * 4.	endOfLine := horizontalBytes.	"Invisible region should be allzero for expand quiet zone"	invisibleMask := ReadStream on:		((Array new: cellSize // 8 withAll: 255),		(Array with: (255 bitXor: ((1 bitShift: (8 - (cellSize \\ 8))) - 1))),		(Array new: (horizontalBytes - (cellSize // 8) - 1) withAll: 0)).	stream := WriteStream on: (ByteArray new: bits size).	1 to: bits size do:		[:idx | | byte |		byte := bits at: idx.		stream nextPut: ((byte bitXor: cycleStream next) bitAnd: invisibleMask next).		cycleStream atEnd ifTrue: [cycleStream reset].		invisibleMask atEnd ifTrue: [invisibleMask reset].		idx = endOfLine			ifTrue: 				[endOfLine := endOfLine + horizontalBytes.				cycle := cycle + 1 \\ (pattern size // 4).				cycleStream := ReadStream on: (pattern copyFrom: cycle * 4 + 1 to: cycle * 4 + 3)]].	^stream contents</body><body package="QRCode">maskFinderPattern: image	"to white"	| cellSize positions |	cellSize := self class cellSizeTable at: version.	positions := ((1 to: 5) collect: [:idx | idx @ 1]),			(Array with: 1@2 with: 1@3 with:1@4),			(Array with: 5@2 with: 5@3 with: 5@4),			((1 to: 5) collect: [:idx | idx @ 5]).	positions do:		[:point | image atPoint: point put: 0].	(positions collect: [:point | (point x + cellSize -7 ) @ (point y)]) do:		[:point | image atPoint: point put: 0].	(positions collect: [:point | (point x) @ (point y+ cellSize -7 )]) do:		[:point | image atPoint: point put: 0].	positions := ((0 to: 6) collect: [:idx | 7 @ idx]).	positions do:		[:point | image atPoint: point put: 0].	(positions collect: [:point | (point x + cellSize - 15) @ point y]) do:		[:point | image atPoint: point put: 0].	(positions collect: [:point | (point x ) @ (point y+ cellSize - 7)]) do:		[:point | image atPoint: point put: 0].	positions := ((0 to: 7) collect: [:idx | idx @ 7]).	positions do:		[:point | image atPoint: point put: 0].	(positions collect: [:point | (point x + cellSize - 8) @ point y]) do:		[:point | image atPoint: point put: 0].	(positions collect: [:point | (point x ) @ (point y+ cellSize - 15)]) do:		[:point | image atPoint: point put: 0].	9 to: cellSize - 10 by: 2 do:		[:idx |		image atPoint: (idx @ 6) put: 0.		image atPoint: (6 @ idx) put: 0.].</body><body package="QRCode">maskFormatInformation: image with: pattern	"to white"	| cellSize forStr |	cellSize := self class cellSizeTable at: version.	forStr := self class formatInformationTable at: (errorCorrectionLevel, (pattern - 1 )printString) asSymbol.	forStr keysAndValuesDo:		[:idx :bit | | x y |		bit = $0			ifTrue:				["Horizontal"				x := idx - 1.				idx = 7 ifTrue: [x := idx].				idx &gt;= 8 ifTrue: [x := cellSize + idx - 16]. 				y := 8.				image atPoint: (x@y) put: 0.				"Vertical"				x := 8.				y := cellSize - idx.				(idx = 8 or: [idx = 9]) ifTrue: [y := 16 - idx].				idx &gt;= 10 ifTrue: [y := 15 - idx].				image atPoint: (x@y) put: 0]]</body><body package="QRCode">maskVersionInformation: image	"to white"	| cellSize verStr |	version &lt; 7 ifTrue: [^self].	cellSize := self class cellSizeTable at: version.	verStr := self class versionInformationTable at: version.	verStr reverse keysAndValuesDo:		[:idx :bit | | x y |		bit = $0			ifTrue:				["Top right"				x := cellSize - 11 + (idx - 1 \\ 3).				y := idx - 1 // 3.				image atPoint: (x@y) put: 0.				"Bottom left"				x := idx - 1 // 3.				y := cellSize - 11 + (idx - 1 \\ 3).				image atPoint: (x@y) put: 0]]</body></methods><methods><class-id>Core.QRCodeGenerator</class-id> <category>private-calculate</category><body package="QRCode">brightAnd11311: image	| cellSize score proc |	cellSize := self class cellSizeTable at: version.	score := 0.	proc :=		[:rotateImage |		0 to: cellSize - 1 do:		[:x | 		0 to: cellSize - 11 do:				[:y |				(((rotateImage atPoint: x @ y) = 1)						and: [((rotateImage atPoint: x @ (y+1)) = 0)						and: [((rotateImage atPoint: x @ (y+2)) = 1)						and: [((rotateImage atPoint: x @ (y+3)) = 1)						and: [((rotateImage atPoint: x @ (y+4)) = 1)						and: [((rotateImage atPoint: x @ (y+5)) = 0)						and: [((rotateImage atPoint: x @ (y+6)) = 1)						and: [((rotateImage atPoint: x @ (y+7)) = 0)						and: [((rotateImage atPoint: x @ (y+8)) = 0)						and: [((rotateImage atPoint: x @ (y+9)) = 0)						and: [((rotateImage atPoint: x @ (y+10)) = 0)]]]]]]]]]])					ifTrue: [score := score + 40]]]].	proc value: image.	proc value: (image rotatedByQuadrants: 1).	proc value: (image rotatedByQuadrants: 2).	proc value: (image rotatedByQuadrants: 3).	^score</body><body package="QRCode">calculatePaneltyScore: image	^(self neighboringModule: image) +	(self moduleBlock: image) +	(self brightAnd11311: image) +	(self darkRate: image)</body><body package="QRCode">darkRate: image	| cellSize darkNum |	cellSize := self class cellSizeTable at: version.	darkNum := 0.	0 to: cellSize - 1 do:		[:x |		0 to: cellSize - 1 do:			[:y | 			darkNum := darkNum + (image atPoint: x @ y)]].	^((50 - (darkNum / (cellSize ** 2) * 100)) abs / 5) ceiling * 10</body><body package="QRCode">moduleBlock: image	| cellSize score |	cellSize := self class cellSizeTable at: version.	score := 0.	0 to: cellSize - 2 do:		[:x |		0 to: cellSize - 2 do:			[:y | | sum |			sum := (image atPoint: x @ y) + (image atPoint: (x+1) @ y) + (image atPoint: x @ (y+1)) + (image atPoint: (x+1) @ (y+1)).			(sum = 0 or: [sum = 4]) ifTrue: [score := score + 3]]].	^score</body><body package="QRCode">neighboringModule: image	| cellSize score |	cellSize := self class cellSizeTable at: version.	score := 0.	0 to: cellSize - 1 do:		[:x | | goOn |		goOn := 1.		0 to: cellSize - 1 do:				[:y |				((y ~= (cellSize - 1)) and: [(image atPoint: x @ y) = (image atPoint: x @ (y + 1))])					ifTrue: [goOn := goOn + 1]					ifFalse:						[goOn &gt;= 5 ifTrue: [score := score + goOn - 2].						goOn := 1]]].	0 to: cellSize - 1 do:		[:y | | goOn |		goOn := 1.		0 to: cellSize - 1 do:				[:x |				((x ~= (cellSize - 1)) and: [(image atPoint: x @ y) = (image atPoint: (x+1) @ y)])					ifTrue:						[goOn := goOn + 1]					ifFalse:						[goOn &gt;= 5 ifTrue: [score := score + goOn - 2].						goOn := 1]]].	^score</body></methods><methods><class-id>Core.QRCodeGenerator class</class-id> <category>instance creation</category><body package="QRCode">getImage: aData	| obj |	obj := self new.	obj data: aData.	^obj getImage</body></methods><methods><class-id>Core.QRCodeGenerator class</class-id> <category>accessing</category><body package="QRCode">alignmentPatternTable	"Zero based"	^#(#()		#(6 18)		#(6 22)		#(6 26)		#(6 30)		#(6 34)		#(6 22 38)		#(6 24 42)		#(6 26 46)		#(6 28 50)		#(6 30 54)		#(6 32 58)		#(6 34 62)		#(6 26 46 66)		#(6 26 48 70)		#(6 26 50 74)		#(6 30 54 78)		#(6 30 56 82)		#(6 30 58 86)		#(6 34 62 90)		#(6 28 50 72 94)		#(6 26 50 74 98)		#(6 30 54 78 102)		#(6 28 54 80 106)		#(6 32 58 84 110)		#(6 30 58 86 114)		#(6 34 62 90 118)		#(6 26 50 74 98 122)		#(6 30 54 78 102 126)		#(6 26 52 78 104 130)		#(6 30 56 82 108 134)		#(6 34 60 86 112 138)		#(6 30 58 86 114 142)		#(6 34 62 90 118 146)		#(6 30 54 78 102 126 150)		#(6 24 50 76 102 128 154)		#(6 28 54 80 106 132 158)		#(6 32 58 84 110 136 162)		#(6 26 54 82 110 138 166)		#(6 30 58 86 114 142 170))</body><body package="QRCode">alphaNumericTable	| dic |	dic := Dictionary new: 45.	dic at: $0 put: 0.	dic at: $1 put: 1.	dic at: $2 put: 2.	dic at: $3 put: 3.	dic at: $4 put: 4.	dic at: $5 put: 5.	dic at: $6 put: 6.	dic at: $7 put: 7.	dic at: $8 put: 8.	dic at: $9 put: 9.	dic at: $A put: 10.	dic at: $B put: 11.	dic at: $C put: 12.	dic at: $D put: 13.	dic at: $E put: 14.	dic at: $F put: 15.	dic at: $G put: 16.	dic at: $H put: 17.	dic at: $I put: 18.	dic at: $J put: 19.	dic at: $K put: 20.	dic at: $L put: 21.	dic at: $M put: 22.	dic at: $N put: 23.	dic at: $O put: 24.	dic at: $P put: 25.	dic at: $Q put: 26.	dic at: $R put: 27.	dic at: $S put: 28.	dic at: $T put: 29.	dic at: $V put: 31.	dic at: $W put: 32.	dic at: $X put: 33.	dic at: $Y put: 34.	dic at: $Z put: 35.	dic at: Character space put: 36.	dic at: $$ put: 37.	dic at: $% put: 38.	dic at: $* put: 39.	dic at: $+ put: 40.	dic at: $- put: 41.	dic at: $. put: 42.	dic at: $/ put: 43.	dic at: $: put: 44.	^dic</body><body package="QRCode">cellSizeTable	^(1 to: 40) collect: [:n | 4 * n + 17]</body><body package="QRCode">dataBlockTable	| dic |	dic := Dictionary new.	dic at: #'1L' put: #(1 26 19 0 0 0).	dic at: #'1M' put: #(1 26 16 0 0 0).	dic at: #'1Q' put: #(1 26 13 0 0 0).	dic at: #'1H' put: #(1 26 9 0 0 0).	dic at: #'2L' put: #(1 44 34 0 0 0).	dic at: #'2M' put: #(1 44 28 0 0 0).	dic at: #'2Q' put: #(1 44 22 0 0 0).	dic at: #'2H' put: #(1 44 16 0 0 0).	dic at: #'3L' put: #(1 70 55 0 0 0).	dic at: #'3M' put: #(1 70 44 0 0 0).	dic at: #'3Q' put: #(2 35 17 0 0 0).	dic at: #'3H' put: #(2 35 13 0 0 0).	dic at: #'4L' put: #(1 100 80 0 0 0).	dic at: #'4M' put: #(2 50 32 0 0 0).	dic at: #'4Q' put: #(2 50 24 0 0 0).	dic at: #'4H' put: #(4 25 9 0 0 0).	dic at: #'5L' put: #(1 134 108 0 0 0).	dic at: #'5M' put: #(2 67 43 0 0 0).	dic at: #'5Q' put: #(2 33 15 2 34 16).	dic at: #'5H' put: #(2 33 11 2 34 12).	dic at: #'6L' put: #(2 86 68 0 0 0).	dic at: #'6M' put: #(4 43 27 0 0 0).	dic at: #'6Q' put: #(4 43 19 0 0 0).	dic at: #'6H' put: #(4 43 15 0 0 0).	dic at: #'7L' put: #(2 98 78 0 0 0).	dic at: #'7M' put: #(4 49 31 0 0 0).	dic at: #'7Q' put: #(2 32 14 4 33 15).	dic at: #'7H' put: #(4 39 13 1 40 14).	dic at: #'8L' put: #(2 121 97 0 0 0).	dic at: #'8M' put: #(2 60 38 2 61 39).	dic at: #'8Q' put: #(4 40 18 2 41 19).	dic at: #'8H' put: #(4 40 14 2 41 15).	dic at: #'9L' put: #(2 146 116 0 0 0).	dic at: #'9M' put: #(3 58 36 2 59 37).	dic at: #'9Q' put: #(4 36 16 4 37 17).	dic at: #'9H' put: #(4 36 12 4 37 13).	dic at: #'10L' put: #(2 86 68 2 87 69).	dic at: #'10M' put: #(4 69 43 1 70 44).	dic at: #'10Q' put: #(6 43 19 2 44 20).	dic at: #'10H' put: #(6 43 15 2 44 16).	dic at: #'11L' put: #(4 101 81 0 0 0).	dic at: #'11M' put: #(1 80 50 4 81 51).	dic at: #'11Q' put: #(4 50 22 4 51 23).	dic at: #'11H' put: #(3 36 12 8 37 13).	dic at: #'12L' put: #(2 116 92 2 117 93).	dic at: #'12M' put: #(6 58 36 2 59 37).	dic at: #'12Q' put: #(4 46 20 6 47 21).	dic at: #'12H' put: #(7 42 14 4 43 15).	dic at: #'13L' put: #(4 133 107 0 0 0).	dic at: #'13M' put: #(8 59 37 1 60 38).	dic at: #'13Q' put: #(8 44 20 4 45 21).	dic at: #'13H' put: #(12 33 11 4 34 12).	dic at: #'14L' put: #(3 145 115 1 146 116).	dic at: #'14M' put: #(4 64 40 5 65 44).	dic at: #'14Q' put: #(11 36 16 5 37 17).	dic at: #'14H' put: #(11 36 12 5 37 13).	dic at: #'15L' put: #(5 109 87 1 110 88).	dic at: #'15M' put: #(5 65 41 5 66 42).	dic at: #'15Q' put: #(5 54 24 7 55 25).	dic at: #'15H' put: #(11 36 12 7 37 13).	dic at: #'16L' put: #(5 122 98 1 123 99).	dic at: #'16M' put: #(7 73 45 3 74 46).	dic at: #'16Q' put: #(15 43 19 2 44 20).	dic at: #'16H' put: #(3 45 15 13 46 16).	dic at: #'17L' put: #(1 135 107 5 136 108).	dic at: #'17M' put: #(10 74 46 1 75 47).	dic at: #'17Q' put: #(1 50 22 15 51 23).	dic at: #'17H' put: #(2 42 14 17 43 15).	dic at: #'18L' put: #(5 150 120 1 151 121).	dic at: #'18M' put: #(9 69 43 4 70 44).	dic at: #'18Q' put: #(17 50 22 1 51 23).	dic at: #'18H' put: #(2 42 14 19 43 15).	dic at: #'19L' put: #(3 141 113 4 142 114).	dic at: #'19M' put: #(3 70 44 11 71 45).	dic at: #'19Q' put: #(17 47 21 4 48 22).	dic at: #'19H' put: #(9 39 13 16 40 14).	dic at: #'20L' put: #(3 135 107 5 136 108).	dic at: #'20M' put: #(3 67 41 13 68 42).	dic at: #'20Q' put: #(15 54 24 5 55 25).	dic at: #'20H' put: #(15 43 15 10 44 16).	dic at: #'21L' put: #(4 144 116 4 145 117).	dic at: #'21M' put: #(17 68 42 0 0 0).	dic at: #'21Q' put: #(17 50 22 6 51 23).	dic at: #'21H' put: #(19 46 16 6 47 17).	dic at: #'22L' put: #(2 139 111 7 140 112).	dic at: #'22M' put: #(17 74 46 0 0 0).	dic at: #'22Q' put: #(7 54 24 16 55 25).	dic at: #'22H' put: #(34 37 13 0 0 0).	dic at: #'23L' put: #(4 151 121 5 152 122).	dic at: #'23M' put: #(4 75 47 14 76 48).	dic at: #'23Q' put: #(11 54 24 14 55 25).	dic at: #'23H' put: #(16 45 15 14 46 16).	dic at: #'24L' put: #(6 147 117 4 148 118).	dic at: #'24M' put: #(6 73 45 14 74 46).	dic at: #'24Q' put: #(11 54 24 16 55 25).	dic at: #'24H' put: #(30 46 16 2 47 17).	dic at: #'25L' put: #(8 132 106 4 133 107).	dic at: #'25M' put: #(8 75 47 13 76 48).	dic at: #'25Q' put: #(7 54 24 22 55 25).	dic at: #'25H' put: #(22 45 15 13 46 16).	dic at: #'26L' put: #(10 142 114 2 143 115).	dic at: #'26M' put: #(19 74 46 4 75 47).	dic at: #'26Q' put: #(28 50 22 6 51 23).	dic at: #'26H' put: #(33 46 16 4 47 17).	dic at: #'27L' put: #(8 152 122 4 153 123).	dic at: #'27M' put: #(22 73 45 3 74 46).	dic at: #'27Q' put: #(8 53 23 26 54 24).	dic at: #'27H' put: #(12 45 15 28 46 16).	dic at: #'28L' put: #(3 147 117 10 148 118).	dic at: #'28M' put: #(3 73 45 23 74 46).	dic at: #'28Q' put: #(4 54 24 31 55 25).	dic at: #'28H' put: #(11 45 15 31 46 16).	dic at: #'29L' put: #(7 146 116 7 147 117).	dic at: #'29M' put: #(21 73 45 7 74 46).	dic at: #'29Q' put: #(1 53 23 37 54 24).	dic at: #'29H' put: #(19 45 15 26 46 16).	dic at: #'30L' put: #(5 145 115 10 146 116).	dic at: #'30M' put: #(19 75 47 10 76 48).	dic at: #'30Q' put: #(15 54 24 25 55 25).	dic at: #'30H' put: #(23 45 15 25 46 16).	dic at: #'31L' put: #(13 145 115 3 146 116).	dic at: #'31M' put: #(2 74 46 29 75 47).	dic at: #'31Q' put: #(42 54 24 1 55 25).	dic at: #'31H' put: #(23 45 15 28 46 16).	dic at: #'32L' put: #(17 145 115 0 0 0).	dic at: #'32M' put: #(10 74 46 23 75 47 ).	dic at: #'32Q' put: #(10 54 24 35 55 25 ).	dic at: #'32H' put: #(19 45 15 35 46 16 ).	dic at: #'33L' put: #(17 145 115 1 146 116).	dic at: #'33M' put: #(14 74 46 21 75 47).	dic at: #'33Q' put: #(29 54 24 19 55 25).	dic at: #'33H' put: #(11 45 15 46 46 16).	dic at: #'34L' put: #(13 145 115 6 146 116).	dic at: #'34M' put: #(14 74 46 23 75 47).	dic at: #'34Q' put: #(44 54 24 7 55 25).	dic at: #'34H' put: #(59 46 16 1 47 17).	dic at: #'35L' put: #(12 151 121 7 152 122).	dic at: #'35M' put: #(12 75 47 26 76 48).	dic at: #'35Q' put: #(39 54 24 14 55 25).	dic at: #'35H' put: #(22 45 15 41 46 16).	dic at: #'36L' put: #(6 151 121 14 152 122).	dic at: #'36M' put: #(6 75 47 34 76 48).	dic at: #'36Q' put: #(46 54 24 10 55 25).	dic at: #'36H' put: #(2 45 15 64 46 16).	dic at: #'37L' put: #(17 152 122 4 153 123).	dic at: #'37M' put: #(29 74 46 14 75 47).	dic at: #'37Q' put: #(49 54 24 10 55 25).	dic at: #'37H' put: #(24 45 15 46 46 16).	dic at: #'38L' put: #(4 152 122 18 153 123).	dic at: #'38M' put: #(13 74 46 32 75 47).	dic at: #'38Q' put: #(48 54 24 14 55 25).	dic at: #'38H' put: #(42 45 15 32 46 16).	dic at: #'39L' put: #(20 147 117 4 148 118).	dic at: #'39M' put: #(40 75 47 7 76 48).	dic at: #'39Q' put: #(43 54 24 22 55 25).	dic at: #'39H' put: #(10 45 15 67 46 16).	dic at: #'40L' put: #(19 148 118 6 149 119).	dic at: #'40M' put: #(18 75 47 31 76 48).	dic at: #'40Q' put: #(34 54 24 34 55 25).	dic at: #'40H' put: #(20 45 15 61 46 16).	^dic</body><body package="QRCode">formatInformationTable	| dic |	dic := Dictionary new.	dic at: #L0 put: '111011111000100'.	dic at: #L1 put: '111001011110011'.	dic at: #L2 put: '111110110101010'.	dic at: #L3 put: '111100010011101'.	dic at: #L4 put: '110011000101111'.	dic at: #L5 put: '110001100011000'.	dic at: #L6 put: '110110001000001'.	dic at: #L7 put: '110100101110110'.	dic at: #M0 put: '101010000010010'.	dic at: #M1 put: '101000100100101'.	dic at: #M2 put: '101111001111100'.	dic at: #M3 put: '101101101001011'.	dic at: #M4 put: '100010111111001'.	dic at: #M5 put: '100000011001110'.	dic at: #M6 put: '100111110010111'.	dic at: #M7 put: '100101010100000'.	dic at: #Q0 put: '011010101011111'.	dic at: #Q1 put: '011000001101000'.	dic at: #Q2 put: '011111100110001'.	dic at: #Q3 put: '011101000000110'.	dic at: #Q4 put: '010010010110100'.	dic at: #Q5 put: '010000110000011'.	dic at: #Q6 put: '010111011011010'.	dic at: #Q7 put: '010101111101101'.	dic at: #H0 put: '001011010001001'.	dic at: #H1 put: '001001110111110'.	dic at: #H2 put: '001110011100111'.	dic at: #H3 put: '001100111010000'.	dic at: #H4 put: '000011101100010'.	dic at: #H5 put: '000001001010101'.	dic at: #H6 put: '000110100001100'.	dic at: #H7 put: '000100000111011'.	^dic</body><body package="QRCode">generatingPolynomialTable	^#(nil nil nil nil nil nil		"7" #(0 87 229 146 149 238 102 21)		nil nil		"10" #(0 251 67 46 61 118 70 64 94 32 45)		nil nil		"13" #(0 74 152 176 100 86 100 106 104 130 218 206 140 78)		nil		"15" #(0 8 183 61 91 202 37 51 58 58 237 140 124 5 99 105)		"16" #(0 120 104 107 109 102 161 76 3 91 191 147 169 182 194 225 120)		"17" #(0 43 139 206 78 43 239 123 206 214 147 24 99 150 39 243 163 136)		"18" #(0 215 234 158 94 184 97 118 170 79 187 152 148 252 179 5 98 96 153)		nil		"20" #(0 17 60 79 50 61 163 26 187 202 180 221 225 83 239 156 164 212 212 188 190)		"21" #(0 240 233 104 247 181 140 67 98 85 200 210 115 148 137 230 36 122 254 148 175 210)		"22" #(0 210 171 247 242 93 230 14 109 221 53 200 74 8 172 98 80 219 134 160 105 165 231)		nil		"24" #(0 229 121 135 48 211 117 251 126 159 180 169 152 192 226 228 218 111 0 117 232 87 96 227 21)		nil		"26" #(0 173 125 158 2 103 182 118 17 145 201 111 28 165 53 161 21 245 142 13 102 48 227 153 145 218 70)		nil		"28" #(0 168 223 200 104 224 234 108 180 110 190 195 147 205 27 232 201 21 43 245 87 42 195 212 119 242 37 9 123)		nil		"30" #(0 41 173 145 152 216 31 179 182 50 48 110 86 239 96 222 125 42 173 226 193 224 130 156 37 251 216 238 40 192 180))</body><body package="QRCode">limitDataLengthTable	| dic |	dic := Dictionary new.	dic at: #'1L' put:19.	dic at: #'1M' put:16.	dic at: #'1Q' put:13.	dic at: #'1H' put:9.	dic at: #'2L' put:34.	dic at: #'2M' put:28.	dic at: #'2Q' put:22.	dic at: #'2H' put:16.	dic at: #'3L' put:55.	dic at: #'3M' put:44.	dic at: #'3Q' put:34.	dic at: #'3H' put:26.	dic at: #'4L' put:80.	dic at: #'4M' put:64.	dic at: #'4Q' put:48.	dic at: #'4H' put:36.	dic at: #'5L' put:108.	dic at: #'5M' put:86.	dic at: #'5Q' put:62.	dic at: #'5H' put:46.	dic at: #'6L' put:136.	dic at: #'6M' put:108.	dic at: #'6Q' put:76.	dic at: #'6H' put:60.	dic at: #'7L' put:156.	dic at: #'7M' put:124.	dic at: #'7Q' put:88.	dic at: #'7H' put:66.	dic at: #'8L' put:194.	dic at: #'8M' put:154.	dic at: #'8Q' put:110.	dic at: #'8H' put:86.	dic at: #'9L' put:232.	dic at: #'9M' put:182.	dic at: #'9Q' put:132.	dic at: #'9H' put:100.	dic at: #'10L' put:274.	dic at: #'10M' put:216.	dic at: #'10Q' put:154.	dic at: #'10H' put:122.	dic at: #'11L' put:324.	dic at: #'11M' put:254.	dic at: #'11Q' put:180.	dic at: #'11H' put:140.	dic at: #'12L' put:370.	dic at: #'12M' put:290.	dic at: #'12Q' put:206.	dic at: #'12H' put:158.	dic at: #'13L' put:428.	dic at: #'13M' put:334.	dic at: #'13Q' put:244.	dic at: #'13H' put:180.	dic at: #'14L' put:461.	dic at: #'14M' put:365.	dic at: #'14Q' put:261.	dic at: #'14H' put:197.	dic at: #'15L' put:523.	dic at: #'15M' put:415.	dic at: #'15Q' put:295.	dic at: #'15H' put:223.	dic at: #'16L' put:589.	dic at: #'16M' put:453.	dic at: #'16Q' put:325.	dic at: #'16H' put:253.	dic at: #'17L' put:647.	dic at: #'17M' put:507.	dic at: #'17Q' put:367.	dic at: #'17H' put:283.	dic at: #'18L' put:721.	dic at: #'18M' put:563.	dic at: #'18Q' put:397.	dic at: #'18H' put:313.	dic at: #'19L' put:795.	dic at: #'19M' put:627.	dic at: #'19Q' put:445.	dic at: #'19H' put:341.	dic at: #'20L' put:861.	dic at: #'20M' put:669.	dic at: #'20Q' put:485.	dic at: #'20H' put:385.	dic at: #'21L' put:932.	dic at: #'21M' put:714.	dic at: #'21Q' put:512.	dic at: #'21H' put:406.	dic at: #'22L' put:1006.	dic at: #'22M' put:782.	dic at: #'22Q' put:568.	dic at: #'22H' put:442.	dic at: #'23L' put:1094.	dic at: #'23M' put:860.	dic at: #'23Q' put:614.	dic at: #'23H' put:464.	dic at: #'24L' put:1174.	dic at: #'24M' put:914.	dic at: #'24Q' put:664.	dic at: #'24H' put:514.	dic at: #'25L' put:1276.	dic at: #'25M' put:1000.	dic at: #'25Q' put:718.	dic at: #'25H' put:538.	dic at: #'26L' put:1370.	dic at: #'26M' put:1062.	dic at: #'26Q' put:754.	dic at: #'26H' put:596.	dic at: #'27L' put:1468.	dic at: #'27M' put:1128.	dic at: #'27Q' put:808.	dic at: #'27H' put:628.	dic at: #'28L' put:1531.	dic at: #'28M' put:1193.	dic at: #'28Q' put:871.	dic at: #'28H' put:661.	dic at: #'29L' put:1631.	dic at: #'29M' put:1267.	dic at: #'29Q' put:911.	dic at: #'29H' put:701.	dic at: #'30L' put:1735.	dic at: #'30M' put:1373.	dic at: #'30Q' put:985.	dic at: #'30H' put:745.	dic at: #'31L' put:1843.	dic at: #'31M' put:1455.	dic at: #'31Q' put:1033.	dic at: #'31H' put:793.	dic at: #'32L' put:1955.	dic at: #'32M' put:1541.	dic at: #'32Q' put:1115.	dic at: #'32H' put:845.	dic at: #'33L' put:2071.	dic at: #'33M' put:1631.	dic at: #'33Q' put:1171.	dic at: #'33H' put:901.	dic at: #'34L' put:2191.	dic at: #'34M' put:1725.	dic at: #'34Q' put:1231.	dic at: #'34H' put:961.	dic at: #'35L' put:2306.	dic at: #'35M' put:1812.	dic at: #'35Q' put:1286.	dic at: #'35H' put:986.	dic at: #'36L' put:2434.	dic at: #'36M' put:1914.	dic at: #'36Q' put:1354.	dic at: #'36H' put:1054.	dic at: #'37L' put:2566.	dic at: #'37M' put:1992.	dic at: #'37Q' put:1426.	dic at: #'37H' put:1096.	dic at: #'38L' put:2702.	dic at: #'38M' put:2102.	dic at: #'38Q' put:1502.	dic at: #'38H' put:1142.	dic at: #'39L' put:2812.	dic at: #'39M' put:2216.	dic at: #'39Q' put:1582.	dic at: #'39H' put:1222.	dic at: #'40L' put:2956.	dic at: #'40M' put:2334.	dic at: #'40Q' put:1666.	dic at: #'40H' put:1276.	^dic</body><body package="QRCode">maskPattern	"bits := ByteArray new: 24 withAll: 0.	image := Image extent: 24 @ 6 		depth: 1 		bitsPerPixel: 1 		palette: MonoMappedPalette whiteBlack 		usingBits: bits.	0 to: 23 do: [:column | 		0 to: 5 do: [:row |			{mask condition} ifTrue: [image atPoint: column @ row put: 1]]].	image yourself"	"0: (row + column) \\ 2 == 0	1: (row) \\ 2 == 0	2: (column) \\ 3 == 0	3: (row + column) \\ 3 == 0	4: ((row // 2) + (column // 3)) \\ 2 == 0	5: ((row * column) \\ 2) + ((row * column) \\ 3) == 0	6: (((row * column) \\ 2) + ((row * column) \\ 3)) \\ 2 == 0	7: (((row + column) \\ 2) + ((row * column) \\ 3)) \\ 2 == 0"	^#(		#[170 170 170 0 85 85 85 0] "cycle by 2 line"		#[255 255 255 0 0 0 0 0] "cycle by 2 line"		#[146 73 36 0] "cycle by 1 line"		#[146 73 36 0 36 146 73 0 73 36 146 0] "cycle by 3 line"		#[227 142 56 0 227 142 56 0 28 113 199 0 28 113 199 0] "cycle by 4 line"		#[255 255 255 0 130 8 32 0 146 73 36 0 170 170 170 0 146 73 36 0 130 8 32 0] "cycle by 6 line"		#[255 255 255 0 227 142 56 0 219 109 182 0 170 170 170 0 182 219 109 0 142 56 227 0] "cycle by 6 line"		#[170 170 170 0 28 113 199 0 142 56 227 0 85 85 85 0 227 142 56 0 113 199 28 0] "cycle by 6 line")</body><body package="QRCode">toExponentTable	^#(0 1 25 2 50 26 198 3		223 51 238 27 104 199 75 4		100 224 14 52 141 239 129 28 193		105 248 200 8 76 113 5 138 101		47 225 36 15 33 53 147 142 218		240 18 130 69 29 181 194 125 106		39 249 185 201 154 9 120 77 228		114 166 6 191 139 98 102 221 48		253 226 152 37 179 16 145 34 136		54 208 148 206 143 150 219 189 241		210 19 92 131 56 70 64 30 66		182 163 195 72 126 110 107 58 40		84 250 133 186 61 202 94 155 159		10 21 121 43 78 212 229 172 115		243 167 87 7 112 192 247 140 128		99 13 103 74 222 237 49 197 254		24 227 165 153 119 38 184 180 124		17 68 146 217 35 32 137 46 55		63 209 91 149 188 207 205 144 135		151 178 220 252 190 97 242 86 211		171 20 42 93 158 132 60 57		83 71 109 65 162 31 45 67		216 183 123 164 118 196 23 73 236		127 12 111 246 108 161 59 82 41		157 85 170 251 96 134 177 187 204		62 90 203 89 95 176 156 169 160		81 11 245 22 235 122 117 44 215		79 174 213 233 230 231 173 232 116		214 244 234 168 80 88 175)</body><body package="QRCode">toIntegerTable	"array of 1 ~ 255"	^#(2 4 8 16 32 64 128		29 58 116 232 205 135 19 38		76 152 45 90 180 117 234 201		143 3 6 12 24 48 96 192		157 39 78 156 37 74 148 53		106 212 181 119 238 193 159 35		70 140 5 10 20 40 80 160		93 186 105 210 185 111 222 161		95 190 97 194 153 47 94 188		101 202 137 15 30 60 120 240		253 231 211 187 107 214 177 127		254 225 223 163 91 182 113 226		217 175 67 134 17 34 68 136		13 26 52 104 208 189 103 206		129 31 62 124 248 237 199 147		59 118 236 197 151 51 102 204		133 23 46 92 184 109 218 169		79 158 33 66 132 21 42 84		168 77 154 41 82 164 85 170		73 146 57 114 228 213 183 115		230 209 191 99 198 145 63 126		252 229 215 179 123 246 241 255		227 219 171 75 150 49 98 196		149 55 110 220 165 87 174 65		130 25 50 100 200 141 7 14		28 56 112 224 221 167 83 166		81 162 89 178 121 242 249 239		195 155 43 86 172 69 138 9		18 36 72 144 61 122 244 245		247 243 251 235 203 139 11 22		44 88 176 125 250 233 207 131		27 54 108 216 173 71 142 1)</body><body package="QRCode">versionInformationTable	^#(nil nil nil nil nil nil		'000111110010010100'		'001000010110111100'		'001001101010011001'		'001010010011010011'		'001011101111110110'		'001100011101100010'		'001101100001000111'		'001110011000001101'		'001111100100101000'		'010000101101111000'		'010001010001011101'		'010010101000010111'		'010011010100110010'		'010100100110100110'		'010101011010000011'		'010110100011001001'		'010111011111101100'		'011000111011000100'		'011001000111100001'		'011010111110101011'		'011011000010001110'		'011100110000011010'		'011101001100111111'		'011110110101110101'		'011111001001010000'		'100000100111010101'		'100001011011110000'		'100010100010111010'		'100011011110011111'		'100100101100001011'		'100101010000101110'		'100110101001100100'		'100111010101000001'		'101000110001101001')</body><body package="QRCode">versionTable	| dic |	dic := Dictionary new.	dic at: #digitL put: #(41 77 127 187 255 322 370 461 552 652 772 883 1022 1101 1250 1408 1548 1725 1903 2061 2232 2409 2620 2812 3057 3283 3517 3669 3909 4158 4417 4686 4965 5253 5529 5836 6153 6479 6743 7089).	dic at: #digitM put: #(34 63 101 149 202 255 293 365 432 513 604 691 796 871 991 1082 1212 1346 1500 1600 1708 1872 2059 2188 2395 2544 2701 2857 3035 3289 3486 3693 3909 4134 4343 4588 4775 5039 5313 5596).	dic at: #digitQ put: #(27 48 77 111 144 178 207 259 312 364 427 489 580 621 703 775 876 948 1063 1159 1224 1358 1468 1588 1718 1804 1933 2085 2181 2358 2473 2670 2805 2949 3081 3244 3417 3599 3791 3993).	dic at: #digitH put: #(17 34 58 82 106 139 154 202 235 288 331 374 427 468 530 602 674 746 813 919 969 1056 1108 1228 1286 1425 1501 1581 1677 1782 1897 2022 2157 2301 2361 2524 2625 2735 2927 3057).	dic at: #alphaNumericL put: #(25 47 77 114 154 195 224 279 335 395 468 535 619 667 758 854 938 1046 1153 1249 1352 1460 1588 1704 1853 1990 2132 2223 2369 2520 2677 2840 3009 3183 3351 3537 3729 3927 4087 4296).	dic at: #alphaNumericM put: #(20 38 61 90 122 154 178 221 262 311 366 419 483 528 600 656 734 816 909 970 1035 1134 1248 1326 1451 1542 1637 1732 1839 1994 2113 2238 2369 2506 2632 2780 2894 3054 3220 3391).	dic at: #alphaNumericQ put: #(16 29 47 67 87 108 125 157 189 221 259 296 352 376 426 470 531 574 644 702 742 823 890 963 1041 1094 1172 1263 1322 1429 1499 1618 1700 1787 1867 1966 2071 2181 2298 2420).	dic at: #alphaNumericH put: #(10 20 35 50 64 84 93 122 143 174 200 227 259 283 321 365 408 452 493 557 587 640 672 744 779 864 910 958 1016 1080 1150 1226 1307 1394 1431 1530 1591 1658 1774 1852).	dic at: #eightBitL put: #(17 32 53 78 106 134 154 192 230 271 321 367 425 458 520 586 644 718 792 858 929 1003 1091 1171 1273 1367 1465 1528 1628 1732 1840 1952 2068 2188 2303 2431 2563 2699 2809 2953).	dic at: #eightBitM put: #(14 26 42 62 84 106 122 152 180 213 251 287 331 362 412 450 504 560 624 666 711 779 857 911 997 1059 1125 1190 1264 1370 1452 1538 1628 1722 1809 1911 1989 2099 2213 2331).	dic at: #eightBitQ put: #(11 20 32 46 60 74 86 108 130 151 177 203 241 258 292 322 364 394 442 482 509 565 611 661 715 751 805 868 908 982 1030 1112 1168 1228 1283 1351 1423 1499 1579 1663).	dic at: #eightBitH put: #(7 14 24 34 44 58 64 84 98 119 137 155 177 194 220 250 280 310 338 382 403 439 461 511 535 593 625 658 698 742 790 842 898 958 983 1051 1093 1139 1219 1273).	dic at: #kanjiL put: #(10 20 32 48 65 82 95 118 141 167 198 226 262 282 320 361 397 442 488 528 572 618 672 721 784 842 902 940 1002 1066 1132 1201 1273 1347 1417 1496 1577 1661 1729 1817).	dic at: #kanjiM put: #(8 16 26 38 52 65 75 93 111 131 155 177 204 223 254 277 310 345 384 410 438 480 528 561 614 652 692 732 778 843 894 947 1002 1060 1113 1176 1224 1292 1362 1435).	dic at: #kanjiQ put: #(7 12 20 28 37 45 53 66 80 93 109 125 149 159 180 198 224 243 272 297 314 348 376 407 440 462 496 534 559 604 634 684 719 756 790 832 876 923 972 1024).	dic at: #kanjiH put: #(4 8 15 21 27 36 39 52 60 74 85 96 109 120 136 154 173 191 208 235 248 270 284 315 330 365 385 405 430 457 486 518 553 590 605 647 673 701 750 784).	^dic</body></methods><methods><class-id>Core.QRCodeGenerator class</class-id> <category>no-longer-using</category><body package="QRCode">calculatePolynomial: arr with: exp	| a1st a2nd ans |	a1st := arr.	a2nd := arr collect: [:i | i + exp \\ 255].	a2nd at: a2nd size put: (a2nd at: a2nd size) \\ 255.	ans := OrderedCollection new: arr size - 1.	(a1st allButFirst: 1) with: (a2nd allButLast: 1) do:		[:n1 :n2 |		ans add: (self new getExponent: ((self new getInteger: n1) bitXor: (self new getInteger: n2)))].	^#(0), ans, (a2nd last: 1)</body><body package="QRCode">getGeneratingPolynomial: exponent	exponent = 1		ifTrue: [^self calculatePolynomial: #(0 0) with: 1]		ifFalse: [^self calculatePolynomial: (self getGeneratingPolynomial: exponent - 1) with: exponent]</body></methods><methods><class-id>Core.QRImageWriteStream</class-id> <category>accessing</category><body package="QRCode">fillToEOL	| widthUnit pointX |	widthUnit := ((cellSize // 32) + 1).	pointX := (position * 8 - 8 + bitPosition) \\ (widthUnit * 32).	self nextPut: 0 fill: widthUnit * 32 -  pointX</body></methods><methods><class-id>Core.QRImageWriteStream</class-id> <category>private</category><body package="QRCode">on: aCellSize	super on: (ByteArray new: ((aCellSize // 32) + 1) * 32 / 8 *  aCellSize).	cellSize := aCellSize</body></methods><methods><class-id>Core.QRImageWriteStream class</class-id> <category>instance creation</category><body package="QRCode">new: size	"Provide an error notification that WriteStreams do not permit read access."	self shouldNotImplement</body><body package="QRCode">newCell: cellSize	^self on: cellSize</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ReadStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>WriteStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class></st-source>